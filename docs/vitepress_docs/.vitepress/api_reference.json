[
  {
    "module_path": "experimental.anonymize_data",
    "module_docstring": {
      "short_description": "Module for anonymizing personally identifiable information (PII) in text.",
      "long_description": "This module provides functionality to detect and replace various types of sensitive\ninformation in German text using named entity recognition, regular expressions, and\nthe Faker library for generating replacement data.",
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [],
    "functions": [
      {
        "name": "anonymize_text",
        "signature": "(text)",
        "is_async": false,
        "docstring": {
          "short_description": "Anonymizes sensitive information (PII) in the input text by replacing it with fake data.",
          "long_description": "This function identifies and replaces the following types of personally identifiable information (PII):\n  - Person names (PER), organization names (ORG), and locations (LOC) using spaCy's named entity recognition\n  - Email addresses using regular expressions\n  - Phone numbers (valid German numbers) using the `phonenumbers` library\n  - IBANs using regular expressions\n  - Street addresses (German format) using regular expressions\n\nThe replacements are done in the following order:\n  1. Named entities (processed from last to first to avoid index shifting)\n  2. Email addresses\n  3. Phone numbers\n  4. IBANs\n  5. Street addresses",
          "params": [
            {
              "name": "text",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "The input text containing sensitive information to be anonymized."
            }
          ],
          "raises": [],
          "returns": {
            "type": "str",
            "description": "The anonymized text with all detected PII replaced by fake data.",
            "name": null
          }
        }
      }
    ]
  },
  {
    "module_path": "experimental.email_extraction",
    "module_docstring": {
      "short_description": "This module provides text cleaning and email signature removal utilities for German text.",
      "long_description": "It includes functions to:\n- Clean German text by removing stop words and converting to lowercase\n- Remove signature blocks from email bodies using pattern matching and NLP techniques\n\nDependencies:\n    spacy: For German NLP processing\n    nltk: For stopword removal and tokenization",
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [],
    "functions": [
      {
        "name": "clean_text",
        "signature": "(text)",
        "is_async": false,
        "docstring": {
          "short_description": "Cleans German text by converting to lowercase and removing stop words.",
          "long_description": "This function processes input text through the following steps:\n1. Converts all text to lowercase\n2. Tokenizes the text into individual words\n3. Removes German stop words using NLTK's predefined list\n4. Rejoins the remaining words into a cleaned string",
          "params": [
            {
              "name": "text",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "The input text to be cleaned"
            }
          ],
          "raises": [],
          "returns": {
            "type": "str",
            "description": "The cleaned text with stop words removed and in lowercase",
            "name": null
          }
        }
      },
      {
        "name": "remove_signature",
        "signature": "(email)",
        "is_async": false,
        "docstring": {
          "short_description": "Removes signature blocks from email bodies using pattern matching and NLP.",
          "long_description": "Processes email content by:\n1. Splitting at common signature separators (e.g., '---', '***')\n2. Removing signature elements through:\n    - Common German/English closing phrases\n    - Contact information patterns (phone, email, etc.)\n    - Company/organization details\n    - Named entity recognition for persons and organizations\n3. Reconstructing the email body with cleaned content",
          "params": [
            {
              "name": "email",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "The full email content including potential signature"
            }
          ],
          "raises": [],
          "returns": {
            "type": "str",
            "description": "The processed email body with signature elements removed",
            "name": null
          }
        }
      }
    ]
  },
  {
    "module_path": "scripts.doc_generation.add_docstrings",
    "module_docstring": {
      "short_description": "Automatically adds long Google style docstrings to Python files using AI.",
      "long_description": null,
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "DocstringGenerator",
        "docstring": {
          "short_description": "Generate docstrings for Python files using an injected AsyncOpenAI client.",
          "long_description": "This class provides functionality to:\n- Discover Python files in a directory while respecting exclusion rules\n- Send file content to an AI model for docstring generation\n- Clean and process AI responses\n- Update files with generated docstrings",
          "params": [
            {
              "name": "client",
              "type": "AsyncOpenAI",
              "default": null,
              "is_optional": false,
              "description": "Asynchronous OpenAI client for API interactions."
            },
            {
              "name": "base_path",
              "type": "Path",
              "default": null,
              "is_optional": false,
              "description": "Root directory to search for Python files."
            },
            {
              "name": "exclude_dirs",
              "type": "set[str]",
              "default": null,
              "is_optional": false,
              "description": "Directory names to exclude from processing."
            },
            {
              "name": "exclude_files",
              "type": "set[str]",
              "default": null,
              "is_optional": false,
              "description": "Specific filenames to exclude from processing."
            },
            {
              "name": "model",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "AI model identifier for docstring generation."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, client: AsyncOpenAI, base_path: Path, exclude_dirs: set[str], exclude_files: set[str], model: str) -> None",
            "is_async": false,
            "docstring": {
              "short_description": "Initialize the DocstringGenerator instance.",
              "long_description": null,
              "params": [
                {
                  "name": "client",
                  "type": "AsyncOpenAI",
                  "default": null,
                  "is_optional": false,
                  "description": "An asynchronous OpenAI client for API interactions."
                },
                {
                  "name": "base_path",
                  "type": "Path",
                  "default": null,
                  "is_optional": false,
                  "description": "Root directory to search for Python files."
                },
                {
                  "name": "exclude_dirs",
                  "type": "set[str]",
                  "default": null,
                  "is_optional": false,
                  "description": "Directory names to exclude from processing."
                },
                {
                  "name": "exclude_files",
                  "type": "set[str]",
                  "default": null,
                  "is_optional": false,
                  "description": "Specific filenames to exclude from processing."
                },
                {
                  "name": "model",
                  "type": "str",
                  "default": null,
                  "is_optional": true,
                  "description": "AI model identifier for docstring generation.\nDefaults to \"deepseek/deepseek-r1-0528\"."
                }
              ],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "find_python_files",
            "signature": "(self) -> list[Path]",
            "is_async": false,
            "docstring": {
              "short_description": "Return all Python files in ``base_path`` respecting exclusion rules.",
              "long_description": "Walks through the directory tree starting at ``base_path`` and collects\nall Python files (.py) that are not in excluded directories or named in\nthe excluded files list.",
              "params": [],
              "raises": [],
              "returns": {
                "type": "list[Path]",
                "description": "List of Path objects representing Python files to process.",
                "name": null
              }
            }
          },
          {
            "name": "clean_ai_response",
            "signature": "(response_text: str) -> str",
            "is_async": false,
            "docstring": {
              "short_description": "Extract Python code from a response that may contain Markdown fences.",
              "long_description": null,
              "params": [
                {
                  "name": "response_text",
                  "type": "str",
                  "default": null,
                  "is_optional": false,
                  "description": "Raw response text from the AI model."
                }
              ],
              "raises": [],
              "returns": {
                "type": "str",
                "description": "Cleaned Python code with Markdown fences removed.",
                "name": null
              }
            }
          },
          {
            "name": "add_docstrings_to_file_content",
            "signature": "(self, file_content: str) -> str | None",
            "is_async": true,
            "docstring": {
              "short_description": "Send file content to the AI model and return the updated version.",
              "long_description": null,
              "params": [
                {
                  "name": "file_content",
                  "type": "str",
                  "default": null,
                  "is_optional": false,
                  "description": "Original Python file content to process."
                }
              ],
              "raises": [],
              "returns": {
                "type": null,
                "description": "str | None: Updated file content with docstrings added, or None on error.",
                "name": null
              }
            }
          },
          {
            "name": "process_file",
            "signature": "(self, file_path: Path) -> None",
            "is_async": true,
            "docstring": {
              "short_description": "Process a single Python file by adding docstrings and saving changes.",
              "long_description": null,
              "params": [
                {
                  "name": "file_path",
                  "type": "Path",
                  "default": null,
                  "is_optional": false,
                  "description": "Path to the Python file to process."
                }
              ],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "run",
            "signature": "(self) -> None",
            "is_async": true,
            "docstring": {
              "short_description": "Run the docstring generation over all discovered Python files.",
              "long_description": "Steps:\n    1. Discovers Python files respecting exclusion rules\n    2. Processes files concurrently using asyncio\n    3. Prints summary upon completion\n\nNote:\n    Skips processing if no Python files are found.",
              "params": [],
              "raises": [],
              "returns": null
            }
          }
        ]
      }
    ],
    "functions": [
      {
        "name": "main",
        "signature": "() -> None",
        "is_async": true,
        "docstring": {
          "short_description": "Parse command-line arguments and run the docstring generation process.",
          "long_description": "This function:\n  - Sets up an argument parser to read command-line options\n  - Validates the provided base directory exists\n  - Initializes the OpenAI client using the OPENAI_API_KEY environment variable\n  - Creates and runs the DocstringGenerator\n\nCommand-line arguments:\n  --base_path: Base directory to search for Python files (default: current directory)\n  --exclude_dirs: Comma-separated list of directories to exclude (default: 'venv,.git')\n  --exclude_files: Comma-separated list of files to exclude (default: '__init__.py')\n  --model: AI model to use for docstring generation (default: 'deepseek/deepseek-r1-0528')",
          "params": [],
          "raises": [
            {
              "name": "SystemExit",
              "type": "SystemExit",
              "default": null,
              "is_optional": null,
              "description": "If base_path doesn't exist or OPENAI_API_KEY is missing."
            }
          ],
          "returns": null
        }
      }
    ]
  },
  {
    "module_path": "scripts.doc_generation.generate_api_reference",
    "module_docstring": {
      "short_description": "A script to generate structured JSON documentation from Python source code.",
      "long_description": "This script uses Python's `ast` module and dataclasses to create a typed,\nstructured representation of the source code. The final output is a JSON file\nready for consumption by front-end frameworks like VitePress/Vue.",
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "ParameterData",
        "docstring": {
          "short_description": "Represents a single parameter from a docstring.",
          "long_description": null,
          "params": [],
          "raises": [],
          "returns": null
        },
        "methods": []
      },
      {
        "name": "ReturnsData",
        "docstring": {
          "short_description": "Represents the returns section of a docstring.",
          "long_description": null,
          "params": [],
          "raises": [],
          "returns": null
        },
        "methods": []
      },
      {
        "name": "DocstringData",
        "docstring": {
          "short_description": "Represents a parsed docstring.",
          "long_description": null,
          "params": [],
          "raises": [],
          "returns": null
        },
        "methods": []
      },
      {
        "name": "FunctionData",
        "docstring": {
          "short_description": "Represents a parsed function or method.",
          "long_description": null,
          "params": [],
          "raises": [],
          "returns": null
        },
        "methods": []
      },
      {
        "name": "ClassData",
        "docstring": {
          "short_description": "Represents a parsed class.",
          "long_description": null,
          "params": [],
          "raises": [],
          "returns": null
        },
        "methods": []
      },
      {
        "name": "ModuleData",
        "docstring": {
          "short_description": "Represents a single parsed Python file.",
          "long_description": null,
          "params": [],
          "raises": [],
          "returns": null
        },
        "methods": []
      },
      {
        "name": "DataClassJSONEncoder",
        "docstring": {
          "short_description": "A JSON encoder that can handle dataclasses.",
          "long_description": null,
          "params": [],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "default",
            "signature": "(self, o)",
            "is_async": false,
            "docstring": {
              "short_description": null,
              "long_description": null,
              "params": [],
              "raises": [],
              "returns": null
            }
          }
        ]
      },
      {
        "name": "JsonVisitor",
        "docstring": {
          "short_description": "An AST visitor that traverses a Python file and builds a collection",
          "long_description": "of dataclass objects representing the documentation structure.",
          "params": [],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "__init__",
            "signature": "(self)",
            "is_async": false,
            "docstring": {
              "short_description": null,
              "long_description": null,
              "params": [],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "visit_ClassDef",
            "signature": "(self, node: ast.ClassDef)",
            "is_async": false,
            "docstring": {
              "short_description": "Processes a class definition.",
              "long_description": null,
              "params": [],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "visit_FunctionDef",
            "signature": "(self, node: ast.FunctionDef)",
            "is_async": false,
            "docstring": {
              "short_description": "Processes a function or method definition.",
              "long_description": null,
              "params": [],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "visit_AsyncFunctionDef",
            "signature": "(self, node: ast.AsyncFunctionDef)",
            "is_async": false,
            "docstring": {
              "short_description": "Processes an async function or method definition.",
              "long_description": null,
              "params": [],
              "raises": [],
              "returns": null
            }
          }
        ]
      }
    ],
    "functions": [
      {
        "name": "parse_python_file",
        "signature": "(file_path: Path) -> tuple[DocstringData, list[ClassData], list[FunctionData]]",
        "is_async": false,
        "docstring": {
          "short_description": "Parses a Python file and returns its documentation components.",
          "long_description": null,
          "params": [],
          "raises": [],
          "returns": null
        }
      },
      {
        "name": "generate_documentation",
        "signature": "(src_path: Path, output_path: Path, exclude_patterns: Optional[list[str]]) -> None",
        "is_async": false,
        "docstring": {
          "short_description": "Generates structured JSON documentation for an entire Python project.",
          "long_description": null,
          "params": [
            {
              "name": "src_path",
              "type": null,
              "default": null,
              "is_optional": null,
              "description": "The root directory of the Python source code."
            },
            {
              "name": "output_path",
              "type": null,
              "default": null,
              "is_optional": null,
              "description": "The file path to save the generated JSON file."
            },
            {
              "name": "exclude_patterns",
              "type": null,
              "default": null,
              "is_optional": null,
              "description": "A list of glob patterns to exclude from parsing."
            }
          ],
          "raises": [],
          "returns": null
        }
      }
    ]
  },
  {
    "module_path": "scripts.doc_generation.generate_multi_lang_docs",
    "module_docstring": {
      "short_description": "Module for translating Markdown documentation files into multiple languages.",
      "long_description": "This module provides functionality to asynchronously translate Markdown files using\nOpenAI's API. It supports translating entire directory structures while preserving\nfile hierarchy and supports multiple target languages.\n\nThe main class `Translator` handles:\n- Initialization with translation parameters\n- Text translation with automatic retries\n- File processing and output writing\n- Concurrent directory translation\n\nExample usage:\n    client = AsyncOpenAI(api_key=\"your_api_key\")\n    translator = Translator(client, base_language=\"en\")\n    asyncio.run(translator.translate_directory(\n        docs_dir=Path(\"docs\"),\n        languages=[\"es\", \"fr\", \"de\"],\n        model=\"gpt-4\",\n        out_dir=Path(\"translated_docs\")\n    ))\n\nNote:\n    The translation instruction prompt is read from 'translation_instruction.txt'\n    by default. This file should contain system instructions for the translation model.",
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "Translator",
        "docstring": {
          "short_description": "Translates Markdown documentation files into multiple languages.",
          "long_description": "This class handles the translation of Markdown files using OpenAI's API. It supports\ntranslating entire directory structures while preserving the file hierarchy and supports\nmultiple target languages.",
          "params": [
            {
              "name": "client",
              "type": "AsyncOpenAI",
              "default": null,
              "is_optional": false,
              "description": "An asynchronous OpenAI client instance for API interactions."
            },
            {
              "name": "base_language",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "The source language of the documents (e.g., 'en')."
            },
            {
              "name": "translation_instruction",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "The system prompt instruction for translation."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, client: AsyncOpenAI, base_language: str, translation_file_path: Path) -> None",
            "is_async": false,
            "docstring": {
              "short_description": "Initializes the Translator instance.",
              "long_description": null,
              "params": [
                {
                  "name": "client",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "An asynchronous OpenAI client instance for API interactions."
                },
                {
                  "name": "base_language",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Language code (e.g., 'en') representing the source language of documents."
                },
                {
                  "name": "translation_file_path",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Path to a file containing the translation instruction for the system prompt.\nIf not provided, defaults to \"translation_instruction.txt\" in the same directory as this module."
                }
              ],
              "raises": [
                {
                  "name": "FileNotFoundError",
                  "type": "FileNotFoundError",
                  "default": null,
                  "is_optional": null,
                  "description": "If the translation instruction file is not found."
                },
                {
                  "name": "OSError",
                  "type": "OSError",
                  "default": null,
                  "is_optional": null,
                  "description": "If there is an error reading the translation instruction file."
                }
              ],
              "returns": null
            }
          },
          {
            "name": "translate_text",
            "signature": "(self, content: str, target_lang: str, model: str) -> str",
            "is_async": true,
            "docstring": {
              "short_description": "Translates Markdown content to a target language using OpenAI's API.",
              "long_description": "This method uses exponential backoff and retries up to 6 times on failure.",
              "params": [
                {
                  "name": "content",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "The Markdown text to translate."
                },
                {
                  "name": "target_lang",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Target language code (e.g., 'es' for Spanish)."
                },
                {
                  "name": "model",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "OpenAI model identifier to use for translation."
                }
              ],
              "raises": [
                {
                  "name": "tenacity.RetryError",
                  "type": "tenacity.RetryError",
                  "default": null,
                  "is_optional": null,
                  "description": "If all retry attempts fail."
                }
              ],
              "returns": {
                "type": null,
                "description": "The translated Markdown content as a string.",
                "name": null
              }
            }
          },
          {
            "name": "process_file",
            "signature": "(self, path: Path, root: Path, languages: List[str], model: str, out_dir: Path) -> None",
            "is_async": true,
            "docstring": {
              "short_description": "Processes a single Markdown file for translation into multiple languages.",
              "long_description": "For each target language:\n1. Reads the source Markdown file\n2. Translates content (skips translation for base language)\n3. Writes translated content to appropriate output path",
              "params": [
                {
                  "name": "path",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Absolute path to the source Markdown file."
                },
                {
                  "name": "root",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Root directory of the documentation source tree."
                },
                {
                  "name": "languages",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "List of target language codes to translate into."
                },
                {
                  "name": "model",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "OpenAI model identifier for translation."
                },
                {
                  "name": "out_dir",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Base output directory for translated files."
                }
              ],
              "raises": [
                {
                  "name": "tenacity.RetryError",
                  "type": "tenacity.RetryError",
                  "default": null,
                  "is_optional": null,
                  "description": "If translation fails after multiple retries."
                },
                {
                  "name": "OSError",
                  "type": "OSError",
                  "default": null,
                  "is_optional": null,
                  "description": "If there is an issue reading the source file or writing the translated file."
                }
              ],
              "returns": null
            }
          },
          {
            "name": "translate_directory",
            "signature": "(self, docs_dir: Path, languages: List[str], model: str, out_dir: Path) -> None",
            "is_async": true,
            "docstring": {
              "short_description": "Translates an entire directory of Markdown files concurrently.",
              "long_description": "Walks through all `.md` files in `docs_dir`, creates translation tasks\nfor each file, and processes them asynchronously.",
              "params": [
                {
                  "name": "docs_dir",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Directory containing source Markdown files."
                },
                {
                  "name": "languages",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "List of target language codes for translation."
                },
                {
                  "name": "model",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "OpenAI model identifier for translation."
                },
                {
                  "name": "out_dir",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Base output directory for translated files."
                }
              ],
              "raises": [
                {
                  "name": "tenacity.RetryError",
                  "type": "tenacity.RetryError",
                  "default": null,
                  "is_optional": null,
                  "description": "If translation of any file fails after retries."
                },
                {
                  "name": "OSError",
                  "type": "OSError",
                  "default": null,
                  "is_optional": null,
                  "description": "If any file I/O operation fails during processing."
                }
              ],
              "returns": null
            }
          }
        ]
      }
    ],
    "functions": []
  },
  {
    "module_path": "scripts.doc_generation.update_frontmatter",
    "module_docstring": {
      "short_description": "Update VitePress frontmatter descriptions in Markdown files.",
      "long_description": "This module provides functionality to parse and update YAML frontmatter in Markdown files\nspecifically for VitePress documentation. It allows updating the 'description' field in\nfrontmatter blocks while preserving the rest of the document structure.\n\nFeatures:\n- Parses frontmatter using regex to extract YAML content\n- Updates frontmatter descriptions while maintaining existing structure\n- Handles file I/O operations with proper encoding\n- Skips non-existent files gracefully\n\nTypical usage:\n    summaries = {'path/to/file.md': 'New summary text'}\n    update_frontmatter(Path('/docs'), summaries)",
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [],
    "functions": [
      {
        "name": "update_frontmatter",
        "signature": "(docs_path: Path, summaries: Dict[str, str]) -> None",
        "is_async": false,
        "docstring": {
          "short_description": "Update the ``description`` key of Markdown frontmatters.",
          "long_description": "Iterates through provided summaries, updating each corresponding Markdown file's\nfrontmatter description. Files are skipped if they don't exist.",
          "params": [
            {
              "name": "docs_path",
              "type": null,
              "default": null,
              "is_optional": null,
              "description": "Root directory containing Markdown documentation files."
            },
            {
              "name": "summaries",
              "type": null,
              "default": null,
              "is_optional": null,
              "description": "Mapping of file paths (relative to ``docs_path``) to summary text.\nThe summary will be written to each file's frontmatter ``description`` field."
            }
          ],
          "raises": [
            {
              "name": "OSError",
              "type": "OSError",
              "default": null,
              "is_optional": null,
              "description": "If file read/write operations fail (e.g., permission issues)."
            },
            {
              "name": "yaml.YAMLError",
              "type": "yaml.YAMLError",
              "default": null,
              "is_optional": null,
              "description": "If existing frontmatter contains invalid YAML syntax."
            }
          ],
          "returns": {
            "type": null,
            "description": "None",
            "name": null
          }
        }
      }
    ]
  },
  {
    "module_path": "scripts.doc_generation_facade",
    "module_docstring": {
      "short_description": "This module provides a facade for generating and translating documentation.",
      "long_description": "It includes functionality to:\n- Generate docstrings for Python source code using AI models\n- Convert documented code into structured Markdown API references\n- Translate documentation files into multiple languages\n\nThe module can be executed as a script to run the full documentation generation\nand translation workflow.",
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "DocGenerationFacade",
        "docstring": {
          "short_description": "Facade for generating documentation from Python code.",
          "long_description": "This class provides a simple interface to generate markdown files\nfrom Python source code, excluding specified directories and files.",
          "params": [],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, client: AsyncOpenAI) -> None",
            "is_async": false,
            "docstring": {
              "short_description": "Initializes the DocGenerationFacade with an AsyncOpenAI client.",
              "long_description": null,
              "params": [
                {
                  "name": "client",
                  "type": "AsyncOpenAI",
                  "default": null,
                  "is_optional": false,
                  "description": "The asynchronous OpenAI client to use for API calls."
                }
              ],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "generate_docstrings",
            "signature": "(self, base_path: Path, exclude_dirs: set[str], exclude_files: set[str], model: str)",
            "is_async": true,
            "docstring": {
              "short_description": "Generates docstrings for Python files in the specified directory tree.",
              "long_description": "This method walks through the directory structure starting at `base_path`,\nprocesses all Python files (excluding specified directories and files), and\nadds missing docstrings using an AI model.",
              "params": [
                {
                  "name": "base_path",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Root directory to start searching for Python files."
                },
                {
                  "name": "exclude_dirs",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Set of directory names to exclude from processing."
                },
                {
                  "name": "exclude_files",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Set of file names to exclude from processing."
                },
                {
                  "name": "model",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Identifier of the AI model to use for docstring generation."
                }
              ],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "generate_markdown",
            "signature": "(self, patterns_to_output_map: dict[str, Path], excluded: list[str])",
            "is_async": false,
            "docstring": {
              "short_description": "Generate markdown files from Python code based on provided patterns.",
              "long_description": null,
              "params": [
                {
                  "name": "patterns_to_output_map",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "A dictionary mapping glob patterns to output file paths.\nEach pattern will be used to find matching files, and the corresponding\noutput path specifies where the generated markdown should be saved."
                },
                {
                  "name": "excluded",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "A list of glob patterns to exclude from processing."
                }
              ],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "translate_docs",
            "signature": "(self, docs_dir: Path, base_language: str, languages: list[str], model: str, out_dir: Path)",
            "is_async": true,
            "docstring": {
              "short_description": "Translates documentation files to multiple target languages.",
              "long_description": "Processes all files in the source directory, translating them from the base language\nto each specified target language using an AI model.",
              "params": [
                {
                  "name": "docs_dir",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Directory containing source documentation files."
                },
                {
                  "name": "base_language",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Language code of the source documentation (e.g., 'en')."
                },
                {
                  "name": "languages",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "List of target language codes to translate to."
                },
                {
                  "name": "model",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Identifier of the AI model to use for translation."
                },
                {
                  "name": "out_dir",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Output directory for translated files."
                }
              ],
              "raises": [],
              "returns": null
            }
          }
        ]
      }
    ],
    "functions": [
      {
        "name": "generate_markdown",
        "signature": "()",
        "is_async": false,
        "docstring": {
          "short_description": "Generates API reference documentation in Markdown format.",
          "long_description": null,
          "params": [],
          "raises": [],
          "returns": null
        }
      },
      {
        "name": "generate_markdown_from_docstrings",
        "signature": "()",
        "is_async": false,
        "docstring": {
          "short_description": "Generates docstrings and converts them to API reference markdown files.",
          "long_description": null,
          "params": [],
          "raises": [],
          "returns": null
        }
      },
      {
        "name": "generate_api_docs_command",
        "signature": "(model: str)",
        "is_async": false,
        "docstring": {
          "short_description": "Generates docstrings and converts them to API reference markdown files.",
          "long_description": null,
          "params": [],
          "raises": [],
          "returns": null
        }
      },
      {
        "name": "create_summaries_command",
        "signature": "(model: str)",
        "is_async": false,
        "docstring": {
          "short_description": "Creates SEO-optimized summaries for all documentation files.",
          "long_description": null,
          "params": [],
          "raises": [],
          "returns": null
        }
      },
      {
        "name": "add_frontmatter_command",
        "signature": "()",
        "is_async": false,
        "docstring": {
          "short_description": "Adds SEO descriptions from the summary file to docs frontmatter.",
          "long_description": null,
          "params": [],
          "raises": [],
          "returns": null
        }
      },
      {
        "name": "translate_command",
        "signature": "(model: str)",
        "is_async": false,
        "docstring": {
          "short_description": "Translates documentation into multiple languages (en, de).",
          "long_description": null,
          "params": [],
          "raises": [],
          "returns": null
        }
      },
      {
        "name": "update_readme_command",
        "signature": "(model: str)",
        "is_async": false,
        "docstring": {
          "short_description": "Updates the main AI_README.md file based on current docs.",
          "long_description": null,
          "params": [],
          "raises": [],
          "returns": null
        }
      },
      {
        "name": "run_all_pipeline",
        "signature": "(model: str)",
        "is_async": false,
        "docstring": {
          "short_description": "Runs the entire documentation generation and translation pipeline.",
          "long_description": null,
          "params": [],
          "raises": [],
          "returns": null
        }
      }
    ]
  },
  {
    "module_path": "scripts.documentation_summary",
    "module_docstring": {
      "short_description": null,
      "long_description": null,
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "DocumentationSummarizer",
        "docstring": {
          "short_description": "Generate summaries for markdown documentation files using OpenAI.",
          "long_description": null,
          "params": [],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, client: AsyncOpenAI, docs_dir: Path) -> None",
            "is_async": false,
            "docstring": {
              "short_description": "Initialize the summarizer.",
              "long_description": null,
              "params": [
                {
                  "name": "client",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Asynchronous OpenAI client used for API calls."
                },
                {
                  "name": "docs_dir",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Path to the directory containing markdown documentation."
                }
              ],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "summarize_file",
            "signature": "(self, path: Path, model: str) -> str",
            "is_async": true,
            "docstring": {
              "short_description": "Return a summary for a single markdown file.",
              "long_description": "Reads the file content and sends it to the OpenAI API for summarization.\nUses a system prompt optimized for Meta SEO descriptions.",
              "params": [
                {
                  "name": "path",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Path to the markdown file."
                },
                {
                  "name": "model",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "OpenAI model identifier (e.g., \"gpt-3.5-turbo\")."
                }
              ],
              "raises": [
                {
                  "name": "OSError",
                  "type": "OSError",
                  "default": null,
                  "is_optional": null,
                  "description": "If the file cannot be read (e.g., file not found or permission issues)."
                },
                {
                  "name": "openai.OpenAIError",
                  "type": "openai.OpenAIError",
                  "default": null,
                  "is_optional": null,
                  "description": "For any errors from the OpenAI API request."
                }
              ],
              "returns": {
                "type": "str",
                "description": "The generated summary text.",
                "name": null
              }
            }
          },
          {
            "name": "create_summary_dict",
            "signature": "(self, model: str) -> dict[str, str]",
            "is_async": true,
            "docstring": {
              "short_description": "Create a mapping of relative file paths to summaries.",
              "long_description": "Walks ``docs_dir`` recursively, summarizing all ``.md`` files concurrently.",
              "params": [
                {
                  "name": "model",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "OpenAI model identifier used for summarization."
                }
              ],
              "raises": [
                {
                  "name": "OSError",
                  "type": "OSError",
                  "default": null,
                  "is_optional": null,
                  "description": "Propagated from file reading errors in ``summarize_file``."
                },
                {
                  "name": "openai.OpenAIError",
                  "type": "openai.OpenAIError",
                  "default": null,
                  "is_optional": null,
                  "description": "Propagated from API errors in ``summarize_file``."
                }
              ],
              "returns": {
                "type": "dict[str, str]",
                "description": "Dictionary mapping relative file paths (as strings) to their summaries.\nPaths are relative to ``docs_dir``.",
                "name": null
              }
            }
          }
        ]
      }
    ],
    "functions": []
  },
  {
    "module_path": "scripts.license_script",
    "module_docstring": {
      "short_description": "Script to update license notices in Python files within a specified directory.",
      "long_description": "This script walks through all Python files in a given directory and replaces\nany existing license notice at the top of the file with a new license notice.\nNon-comment code and empty/whitespace-only files are handled appropriately.",
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [],
    "functions": [
      {
        "name": "find_start_of_code",
        "signature": "(lines)",
        "is_async": false,
        "docstring": {
          "short_description": "Return the index of the first non-comment line.",
          "long_description": "Scans through lines until it finds the first line that contains non-whitespace\ncharacters and doesn't start with a '#' comment marker.",
          "params": [
            {
              "name": "lines",
              "type": "list",
              "default": null,
              "is_optional": false,
              "description": "List of strings representing lines in a file."
            }
          ],
          "raises": [],
          "returns": {
            "type": "int",
            "description": "Index of the first line that is not a comment or whitespace.\nReturns len(lines) if no such line exists.",
            "name": null
          }
        }
      },
      {
        "name": "read_file",
        "signature": "(filepath)",
        "is_async": false,
        "docstring": {
          "short_description": "Read all lines from ``filepath``.",
          "long_description": "Opens the specified file in read mode and returns all lines as a list of strings.",
          "params": [
            {
              "name": "filepath",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "Path to the file to read."
            }
          ],
          "raises": [],
          "returns": {
            "type": "list",
            "description": "List of strings representing lines in the file.",
            "name": null
          }
        }
      },
      {
        "name": "write_file",
        "signature": "(filepath, lines)",
        "is_async": false,
        "docstring": {
          "short_description": "Write ``lines`` to ``filepath``.",
          "long_description": "Opens the specified file in write mode and writes all lines to it.",
          "params": [
            {
              "name": "filepath",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "Path to the file to write."
            },
            {
              "name": "lines",
              "type": "list",
              "default": null,
              "is_optional": false,
              "description": "List of strings to write to the file."
            }
          ],
          "raises": [],
          "returns": null
        }
      },
      {
        "name": "update_license_in_files",
        "signature": "(directory)",
        "is_async": false,
        "docstring": {
          "short_description": "Inserts the license notice at the top of all `.py` files.",
          "long_description": "Walks through all Python files in the specified directory and inserts the new license notice.\nThe function removes any leading comments and blank lines (which typically include the old license)\nand replaces them with the new license notice, except in the case where the file consists entirely\nof comments and blank lines (and is not empty or entirely whitespace). In that case, the new license\nis inserted at the top and the existing comments and blank lines are preserved below.\n\nFor empty files or files containing only whitespace, the license notice is inserted and the rest of\nthe file remains empty.",
          "params": [
            {
              "name": "directory",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "Path to the directory containing files to update."
            }
          ],
          "raises": [],
          "returns": null
        }
      }
    ]
  },
  {
    "module_path": "scripts.readme_updater",
    "module_docstring": {
      "short_description": null,
      "long_description": null,
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "ReadmeUpdater",
        "docstring": {
          "short_description": "Update the AI_README file based on project documentation.",
          "long_description": null,
          "params": [],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, client: AsyncOpenAI, docs_dir: Path, readme_path: Path, model: str) -> None",
            "is_async": false,
            "docstring": {
              "short_description": "Store dependencies for later use.",
              "long_description": null,
              "params": [
                {
                  "name": "client",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Asynchronous OpenAI client."
                },
                {
                  "name": "docs_dir",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Path to the directory containing Markdown documentation."
                },
                {
                  "name": "readme_path",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Path to the AI_README file to update."
                },
                {
                  "name": "model",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Name of the model used for text generation."
                }
              ],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "update_ai_prompt",
            "signature": "(self) -> None",
            "is_async": true,
            "docstring": {
              "short_description": "Generate a new README from documentation and save it.",
              "long_description": "This method performs the following steps:\n1. Collects all Markdown files (recursively) from the stored documentation directory\n   and includes predefined important non-Markdown files.\n2. Constructs a prompt by concatenating file contents with headers indicating their relative paths.\n3. Uses the OpenAI API to generate an updated README based on the documentation.\n4. Appends the project's directory structure to the generated content.\n5. Writes the final content to the stored readme path.\n\nThe system message for the OpenAI API instructs the model to:\n- Update the project summary (AI_README.md)\n- Pay special attention to files in the '/api' directory\n- Return only the updated README in Markdown format\n\nThe generation temperature is set to 0.2 for more deterministic outputs.",
              "params": [],
              "raises": [
                {
                  "name": "FileNotFoundError",
                  "type": "FileNotFoundError",
                  "default": null,
                  "is_optional": null,
                  "description": "If the documentation directory or a Markdown file is not found."
                },
                {
                  "name": "OSError",
                  "type": "OSError",
                  "default": null,
                  "is_optional": null,
                  "description": "If an I/O error occurs during file operations."
                },
                {
                  "name": "openai.OpenAIError",
                  "type": "openai.OpenAIError",
                  "default": null,
                  "is_optional": null,
                  "description": "If the OpenAI API request fails."
                }
              ],
              "returns": null
            }
          }
        ]
      }
    ],
    "functions": []
  },
  {
    "module_path": "scripts.update_file_path_comments",
    "module_docstring": {
      "short_description": "Utility to update FILE_PATH comments in Python files.",
      "long_description": "This script walks through all Python files in a given directory tree\n(excluding ``__init__.py`` files). For each file it removes any lines\nstarting with ``# FILE_PATH:`` and inserts a new comment as the very\nfirst line with the relative path of the file to the project root.",
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [],
    "functions": [
      {
        "name": "update_file",
        "signature": "(file_path: Path, project_root: Path) -> None",
        "is_async": false,
        "docstring": {
          "short_description": "Update the FILE_PATH comment of ``file_path``.",
          "long_description": "Existing comments that match the ``FILE_PATH_PATTERN`` are removed and a\nsingle line ``# FILE_PATH: <relative>`` is inserted at the top of the file.",
          "params": [
            {
              "name": "file_path",
              "type": null,
              "default": null,
              "is_optional": null,
              "description": "Absolute path to the Python file to update."
            },
            {
              "name": "project_root",
              "type": null,
              "default": null,
              "is_optional": null,
              "description": "Root directory of the project (used to calculate relative path)."
            }
          ],
          "raises": [],
          "returns": null
        }
      },
      {
        "name": "process_directory",
        "signature": "(directory: Path) -> None",
        "is_async": false,
        "docstring": {
          "short_description": "Process all Python files under ``directory``.",
          "long_description": "Walks through all Python files in the directory tree (excluding ``__init__.py`` files),\nupdating each file's FILE_PATH comment relative to the project root.",
          "params": [
            {
              "name": "directory",
              "type": null,
              "default": null,
              "is_optional": null,
              "description": "Root directory to start processing from."
            }
          ],
          "raises": [],
          "returns": null
        }
      },
      {
        "name": "main",
        "signature": "() -> None",
        "is_async": false,
        "docstring": {
          "short_description": "Main entry point for the script.",
          "long_description": "Processes all Python files in the project's code root directory.",
          "params": [],
          "raises": [],
          "returns": null
        }
      }
    ]
  },
  {
    "module_path": "scripts.util.display_file_structure",
    "module_docstring": {
      "short_description": "Generates a directory tree structure while respecting `.gitignore` rules.",
      "long_description": "This module provides functionality to traverse a directory hierarchy, exclude files\nand directories specified in a `.gitignore` file, and generate a visual tree\nrepresentation of the structure using the `rich` library.",
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [],
    "functions": [
      {
        "name": "load_gitignore",
        "signature": "(base_path: Path) -> PathSpec",
        "is_async": false,
        "docstring": {
          "short_description": "Loads and parses a .gitignore file into a PathSpec object.",
          "long_description": null,
          "params": [
            {
              "name": "base_path",
              "type": "Path",
              "default": null,
              "is_optional": false,
              "description": "The directory path containing the .gitignore file."
            }
          ],
          "raises": [],
          "returns": {
            "type": "PathSpec",
            "description": "A PathSpec object representing the ignore patterns. Returns an empty\nPathSpec if no .gitignore file exists.",
            "name": null
          }
        }
      },
      {
        "name": "build_tree",
        "signature": "(base_path: Path, spec: PathSpec, tree: Tree, relative_path)",
        "is_async": false,
        "docstring": {
          "short_description": "Recursively builds a directory tree structure while respecting gitignore rules.",
          "long_description": "Walks through the directory structure starting at `base_path`, adding nodes to the\nprovided `tree` object. Files/directories matching .gitignore patterns are excluded.",
          "params": [
            {
              "name": "base_path",
              "type": "Path",
              "default": null,
              "is_optional": false,
              "description": "The root directory to start building the tree from."
            },
            {
              "name": "spec",
              "type": "PathSpec",
              "default": null,
              "is_optional": false,
              "description": "PathSpec object containing gitignore patterns."
            },
            {
              "name": "tree",
              "type": "Tree",
              "default": null,
              "is_optional": false,
              "description": "Rich Tree object to populate with directory structure."
            },
            {
              "name": "relative_path",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "Internal path accumulator for recursion (default: \"\")."
            }
          ],
          "raises": [],
          "returns": null
        }
      },
      {
        "name": "get_tree_str",
        "signature": "(tree: Tree) -> str",
        "is_async": false,
        "docstring": {
          "short_description": "Renders a Rich Tree object to a string representation.",
          "long_description": null,
          "params": [
            {
              "name": "tree",
              "type": "Tree",
              "default": null,
              "is_optional": false,
              "description": "Rich Tree object to render."
            }
          ],
          "raises": [],
          "returns": {
            "type": "str",
            "description": "String representation of the tree structure.",
            "name": null
          }
        }
      },
      {
        "name": "display_dir_tree",
        "signature": "(path_str: str) -> str",
        "is_async": false,
        "docstring": {
          "short_description": "Generates a visual directory tree structure respecting .gitignore rules.",
          "long_description": null,
          "params": [
            {
              "name": "path_str",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "Path to the root directory to visualize."
            }
          ],
          "raises": [],
          "returns": {
            "type": "str",
            "description": "Formatted string representation of the directory tree.",
            "name": null
          }
        }
      }
    ]
  },
  {
    "module_path": "src.ce.app",
    "module_docstring": {
      "short_description": "Main application module for OpenTicketAI.",
      "long_description": "This module contains the `App` class which serves as the primary entry point\nfor the OpenTicketAI system. It orchestrates configuration validation, job\nscheduling, and continuous execution of scheduled tasks.",
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "App",
        "docstring": {
          "short_description": "Main application entry point for the OpenTicketAI system.",
          "long_description": "This class initializes and runs the core application components including:\n- Configuration management\n- Configuration validation\n- Job orchestration and scheduling\n\nThe application follows a scheduled execution model where jobs are run at\npredefined intervals.",
          "params": [
            {
              "name": "config",
              "type": null,
              "default": null,
              "is_optional": null,
              "description": "Loaded application configuration."
            },
            {
              "name": "validator",
              "type": null,
              "default": null,
              "is_optional": null,
              "description": "Configuration validator instance."
            },
            {
              "name": "orchestrator",
              "type": null,
              "default": null,
              "is_optional": null,
              "description": "Job orchestration manager."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, config: OpenTicketAIConfig, validator: OpenTicketAIConfigValidator, orchestrator: Orchestrator)",
            "is_async": false,
            "docstring": {
              "short_description": "Initialize the application with dependencies.",
              "long_description": null,
              "params": [
                {
                  "name": "config",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Loaded configuration for the application containing all\nnecessary parameters and settings."
                },
                {
                  "name": "validator",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Validator instance used to check the integrity and\ncorrectness of the configuration."
                },
                {
                  "name": "orchestrator",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Orchestrator instance responsible for setting up and\nmanaging scheduled jobs and attribute predictors."
                }
              ],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "run",
            "signature": "(self)",
            "is_async": false,
            "docstring": {
              "short_description": "Main execution method for the application.",
              "long_description": "Performs the following operations:\n1. Validates the application configuration\n2. Sets up scheduled jobs using the orchestrator\n3. Enters an infinite loop to execute pending scheduled tasks\n\nThe method first validates the configuration registry. If validation fails,\nan error is logged and the application proceeds to setup schedules without\nvalid configuration (which may cause runtime errors). On successful validation,\na success message is printed.\n\nAfter setup, the method enters a continuous loop that:\n- Checks for pending scheduled jobs every second\n- Executes any pending jobs found\n\nNote:\n    This method runs indefinitely until interrupted by the user or an unhandled exception.",
              "params": [],
              "raises": [
                {
                  "name": "KeyboardInterrupt",
                  "type": "KeyboardInterrupt",
                  "default": null,
                  "is_optional": null,
                  "description": "If the program is interrupted by the user (e.g., via Ctrl+C)."
                },
                {
                  "name": "Exception",
                  "type": "Exception",
                  "default": null,
                  "is_optional": null,
                  "description": "Any unhandled exception occurring during the execution of a scheduled job."
                }
              ],
              "returns": null
            }
          }
        ]
      }
    ],
    "functions": []
  },
  {
    "module_path": "src.ce.core.config.config_models",
    "module_docstring": {
      "short_description": null,
      "long_description": null,
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "ProvidableConfig",
        "docstring": {
          "short_description": "Base configuration for registry instances.",
          "long_description": "This class defines the core configuration structure required for initializing\nand managing registry instances. Each registry instance must have a unique\nidentifier, a provider key, and can include additional provider-specific\nparameters.",
          "params": [
            {
              "name": "id",
              "type": null,
              "default": null,
              "is_optional": null,
              "description": "A unique string identifier for the registry instance. Must be at least\n1 character long."
            },
            {
              "name": "params",
              "type": null,
              "default": null,
              "is_optional": null,
              "description": "A dictionary of additional configuration parameters specific to the\nregistry provider. Defaults to an empty dictionary."
            },
            {
              "name": "provider_key",
              "type": null,
              "default": null,
              "is_optional": null,
              "description": "A string key identifying the provider implementation for this\nregistry instance. Must be at least 1 character long."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": []
      },
      {
        "name": "SystemConfig",
        "docstring": {
          "short_description": "Configuration for the ticket system adapter.",
          "long_description": null,
          "params": [
            {
              "name": "params",
              "type": "dict[str, Any]",
              "default": null,
              "is_optional": false,
              "description": "A dictionary of parameters specific to the ticket system adapter."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": []
      },
      {
        "name": "FetcherConfig",
        "docstring": {
          "short_description": "Configuration for data fetchers.",
          "long_description": "This class represents the configuration for a data fetcher component. It inherits all attributes\nfrom `ProvidableConfig`.",
          "params": [],
          "raises": [],
          "returns": null
        },
        "methods": []
      },
      {
        "name": "PreparerConfig",
        "docstring": {
          "short_description": "Configuration for data preparers.",
          "long_description": "This class represents the configuration for a data preparer component. It inherits all attributes\nfrom `ProvidableConfig`.",
          "params": [],
          "raises": [],
          "returns": null
        },
        "methods": []
      },
      {
        "name": "ModifierConfig",
        "docstring": {
          "short_description": "Configuration for modifiers.",
          "long_description": "This class represents the configuration for a modifier component. It inherits all attributes\nfrom `ProvidableConfig`.",
          "params": [],
          "raises": [],
          "returns": null
        },
        "methods": []
      },
      {
        "name": "AIInferenceServiceConfig",
        "docstring": {
          "short_description": "Configuration for AI inference services.",
          "long_description": "This class represents the configuration for an AI inference service component. It inherits all attributes\nfrom `ProvidableConfig`.",
          "params": [],
          "raises": [],
          "returns": null
        },
        "methods": []
      },
      {
        "name": "SchedulerConfig",
        "docstring": {
          "short_description": "Configuration for scheduling recurring tasks.",
          "long_description": null,
          "params": [
            {
              "name": "interval",
              "type": "int",
              "default": null,
              "is_optional": false,
              "description": "The interval of time to wait between runs. Must be at least 1."
            },
            {
              "name": "unit",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "The unit of time for the interval (e.g., 'minutes', 'hours'). Must be non-empty."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": []
      },
      {
        "name": "PipelineConfig",
        "docstring": {
          "short_description": "Configuration for a single pipeline workflow.",
          "long_description": null,
          "params": [
            {
              "name": "schedule",
              "type": "SchedulerConfig",
              "default": null,
              "is_optional": false,
              "description": "The scheduling configuration for this pipeline."
            },
            {
              "name": "pipes",
              "type": "list[str]",
              "default": null,
              "is_optional": false,
              "description": "Ordered list of all pipe component IDs to execute, starting with a fetcher.\nThe list must have at least one element."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "validate_pipe_ids_are_registered",
            "signature": "(self, all_pipe_ids: set[str]) -> None",
            "is_async": false,
            "docstring": {
              "short_description": "Validate that all pipe IDs in this pipeline exist.",
              "long_description": null,
              "params": [
                {
                  "name": "all_pipe_ids",
                  "type": "set[str]",
                  "default": null,
                  "is_optional": false,
                  "description": "A set of all registered pipe component IDs."
                }
              ],
              "raises": [
                {
                  "name": "ValueError",
                  "type": "ValueError",
                  "default": null,
                  "is_optional": null,
                  "description": "If any pipe ID in this pipeline is not found in `all_pipe_ids`."
                }
              ],
              "returns": null
            }
          }
        ]
      },
      {
        "name": "OpenTicketAIConfig",
        "docstring": {
          "short_description": "Root configuration model for Open Ticket AI.",
          "long_description": null,
          "params": [
            {
              "name": "system",
              "type": "SystemConfig",
              "default": null,
              "is_optional": false,
              "description": "Configuration for the ticket system adapter."
            },
            {
              "name": "fetchers",
              "type": "list[FetcherConfig]",
              "default": null,
              "is_optional": false,
              "description": "List of data fetcher configurations. Must be non-empty."
            },
            {
              "name": "data_preparers",
              "type": "list[PreparerConfig]",
              "default": null,
              "is_optional": false,
              "description": "List of data preparer configurations. Must be non-empty."
            },
            {
              "name": "ai_inference_services",
              "type": "list[AIInferenceServiceConfig]",
              "default": null,
              "is_optional": false,
              "description": "List of AI inference service configurations. Must be non-empty."
            },
            {
              "name": "modifiers",
              "type": "list[ModifierConfig]",
              "default": null,
              "is_optional": false,
              "description": "List of modifier configurations. Must be non-empty."
            },
            {
              "name": "pipelines",
              "type": "list[PipelineConfig]",
              "default": null,
              "is_optional": false,
              "description": "List of pipeline configurations. Must be non-empty."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "cross_validate_references",
            "signature": "(self) -> Self",
            "is_async": false,
            "docstring": {
              "short_description": "Validate that all pipeline references to components exist.",
              "long_description": "This method is called by Pydantic during model validation. It checks that every pipe ID\nreferenced in every pipeline exists in the set of all registered component IDs.",
              "params": [],
              "raises": [
                {
                  "name": "ValueError",
                  "type": "ValueError",
                  "default": null,
                  "is_optional": null,
                  "description": "If any pipeline references a pipe ID that is not registered."
                }
              ],
              "returns": {
                "type": "Self",
                "description": "The validated model instance.",
                "name": null
              }
            }
          },
          {
            "name": "get_all_register_instance_configs",
            "signature": "(self) -> list[ProvidableConfig]",
            "is_async": false,
            "docstring": {
              "short_description": "Return all registered instances in the configuration.",
              "long_description": "The returned list includes all instances of fetchers, data preparers, AI inference services,\nmodifiers, and pipelines.",
              "params": [],
              "raises": [],
              "returns": {
                "type": "list[ProvidableConfig]",
                "description": "A list of all registered instance configurations.",
                "name": null
              }
            }
          }
        ]
      }
    ],
    "functions": [
      {
        "name": "load_config",
        "signature": "(path: str) -> OpenTicketAIConfig",
        "is_async": false,
        "docstring": {
          "short_description": "Load a YAML configuration file from the given path.",
          "long_description": "The configuration file must have a root key 'open_ticket_ai' containing the configuration.",
          "params": [
            {
              "name": "path",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "The path to the YAML configuration file."
            }
          ],
          "raises": [
            {
              "name": "OSError",
              "type": "OSError",
              "default": null,
              "is_optional": null,
              "description": "If there is an error opening the file (e.g., file not found, permission denied)."
            },
            {
              "name": "yaml.YAMLError",
              "type": "yaml.YAMLError",
              "default": null,
              "is_optional": null,
              "description": "If there is an error parsing the YAML."
            },
            {
              "name": "KeyError",
              "type": "KeyError",
              "default": null,
              "is_optional": null,
              "description": "If the root key 'open_ticket_ai' is missing."
            },
            {
              "name": "pydantic.ValidationError",
              "type": "pydantic.ValidationError",
              "default": null,
              "is_optional": null,
              "description": "If the configuration data does not match the expected schema."
            }
          ],
          "returns": {
            "type": "OpenTicketAIConfig",
            "description": "The loaded configuration.",
            "name": null
          }
        }
      }
    ]
  },
  {
    "module_path": "src.ce.core.config.config_validator",
    "module_docstring": {
      "short_description": "Module for validating OpenTicketAI configuration against a registry.",
      "long_description": "This module provides the `OpenTicketAIConfigValidator` class which validates\nthat all provider configurations reference registered providers in the registry.\nIt ensures the application configuration only uses available implementations\nduring runtime initialization.",
      "params": [],
      "raises": [
        {
          "name": "ValueError",
          "type": "ValueError",
          "default": null,
          "is_optional": null,
          "description": "If any configured provider is not found in the registry,\nincluding details of missing IDs and available providers."
        }
      ],
      "returns": null
    },
    "classes": [
      {
        "name": "OpenTicketAIConfigValidator",
        "docstring": {
          "short_description": "Validate configuration values against the registry.",
          "long_description": "This class performs validation checks to ensure all provider configurations\nspecified in the application settings correspond to registered implementations\nin the dependency injection registry.",
          "params": [
            {
              "name": "config",
              "type": "OpenTicketAIConfig",
              "default": null,
              "is_optional": false,
              "description": "Loaded application configuration."
            },
            {
              "name": "registry",
              "type": "Registry",
              "default": null,
              "is_optional": false,
              "description": "Dependency injection registry containing provider mappings."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, config: OpenTicketAIConfig, registry: Registry)",
            "is_async": false,
            "docstring": {
              "short_description": "Create a new validator.",
              "long_description": null,
              "params": [
                {
                  "name": "config",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Loaded `OpenTicketAIConfig` instance."
                },
                {
                  "name": "registry",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Registry containing available classes."
                }
              ],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "validate_registry",
            "signature": "(self) -> None",
            "is_async": false,
            "docstring": {
              "short_description": "Ensure all configured providers are registered.",
              "long_description": "Iterates through all provider configurations in the application settings\nand verifies each provider key exists in the registry. Raises a detailed\nerror if any provider is missing.",
              "params": [],
              "raises": [
                {
                  "name": "ValueError",
                  "type": "ValueError",
                  "default": null,
                  "is_optional": null,
                  "description": "If any provider configuration references an unregistered\nprovider key. The error message includes:\n- Missing provider ID\n- Descriptions of currently registered providers"
                }
              ],
              "returns": null
            }
          }
        ]
      }
    ],
    "functions": []
  },
  {
    "module_path": "src.ce.core.dependency_injection.abstract_container",
    "module_docstring": {
      "short_description": null,
      "long_description": null,
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "AbstractContainer",
        "docstring": {
          "short_description": "Abstract interface for dependency containers.",
          "long_description": "This class defines the contract for dependency injection containers that manage\nobject instances. Implementations should provide mechanisms to register and\nretrieve instances based on provider keys and type constraints.\n\nThe container acts as a central registry that decouples object creation and\ndependencies from their usage, enabling more modular and testable code.",
          "params": [],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "get_instance",
            "signature": "(self, provider_key: str, subclass_of: type[T]) -> T",
            "is_async": false,
            "docstring": {
              "short_description": "Retrieve an instance from the container.",
              "long_description": "The instance is retrieved based on the provider key and must be a subclass of the given type.",
              "params": [
                {
                  "name": "provider_key",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "The key identifying the provider for the instance."
                },
                {
                  "name": "subclass_of",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "The class (or type) of the instance to be retrieved. The type T must be a subclass of\n`Providable`."
                }
              ],
              "raises": [
                {
                  "name": "InstanceNotFoundError",
                  "type": "InstanceNotFoundError",
                  "default": null,
                  "is_optional": null,
                  "description": "If no instance matching the provider key is found."
                },
                {
                  "name": "TypeMismatchError",
                  "type": "TypeMismatchError",
                  "default": null,
                  "is_optional": null,
                  "description": "If the found instance is not a subclass of the specified type."
                }
              ],
              "returns": {
                "type": null,
                "description": "An instance of the type specified by `subclass_of`.",
                "name": null
              }
            }
          }
        ]
      }
    ],
    "functions": []
  },
  {
    "module_path": "src.ce.core.dependency_injection.container",
    "module_docstring": {
      "short_description": "Dependency injection container setup for Open Ticket AI.",
      "long_description": "This module defines the `DIContainer` class which is the central dependency injection\ncontainer for the application. It also includes the `AppModule` which configures\nthe core bindings for the application.\n\nThe container is responsible for:\n    - Loading and validating the application configuration\n    - Creating a registry of available components\n    - Binding core services (like the ticket system client)\n    - Providing methods to retrieve configured instances and pipelines",
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "AppModule",
        "docstring": {
          "short_description": "Injector module that binds the validated configuration.",
          "long_description": null,
          "params": [],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "configure",
            "signature": "(self, binder: Binder)",
            "is_async": false,
            "docstring": {
              "short_description": "Bind core configuration objects.",
              "long_description": null,
              "params": [
                {
                  "name": "binder",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "The Injector binder used to configure bindings."
                }
              ],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "provide_validator",
            "signature": "(self, config: OpenTicketAIConfig, registry: Registry) -> OpenTicketAIConfigValidator",
            "is_async": false,
            "docstring": {
              "short_description": "Provide a configuration validator instance.",
              "long_description": null,
              "params": [
                {
                  "name": "config",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "The application configuration to validate."
                },
                {
                  "name": "registry",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "The registry of available components."
                }
              ],
              "raises": [],
              "returns": {
                "type": "OpenTicketAIConfigValidator",
                "description": "The validator instance.",
                "name": null
              }
            }
          },
          {
            "name": "provide_otobo_client",
            "signature": "(self, config: OpenTicketAIConfig) -> OTOBOClient",
            "is_async": false,
            "docstring": {
              "short_description": "Create an `OTOBOClient` using the system configuration.",
              "long_description": null,
              "params": [
                {
                  "name": "config",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "The application configuration containing system parameters."
                }
              ],
              "raises": [],
              "returns": {
                "type": "OTOBOClient",
                "description": "Configured OTOBO client.",
                "name": null
              }
            }
          }
        ]
      },
      {
        "name": "DIContainer",
        "docstring": {
          "short_description": "Dependency injection container for Open Ticket AI.",
          "long_description": "This container manages the application's dependency graph using Injector.\nIt binds core components like configuration, registry, and orchestrator,\nand provides methods to retrieve configured instances.",
          "params": [
            {
              "name": "config",
              "type": null,
              "default": null,
              "is_optional": null,
              "description": "Validated application configuration"
            },
            {
              "name": "registry",
              "type": null,
              "default": null,
              "is_optional": null,
              "description": "Registry of available components"
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "__init__",
            "signature": "(self)",
            "is_async": false,
            "docstring": {
              "short_description": "Initializes the dependency injection container.",
              "long_description": "Performs the following setup:\n1. Initializes the Injector superclass with AppModule bindings\n2. Binds core configuration and registry as instance attributes\n3. Creates and binds the TicketSystemAdapter instance based on configuration",
              "params": [],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "get_instance_config",
            "signature": "(self, id: str)",
            "is_async": false,
            "docstring": {
              "short_description": "Retrieve the configuration for a specific instance by its ID.",
              "long_description": null,
              "params": [
                {
                  "name": "id",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "The unique identifier of the instance configuration to retrieve."
                }
              ],
              "raises": [
                {
                  "name": "KeyError",
                  "type": "KeyError",
                  "default": null,
                  "is_optional": null,
                  "description": "If no configuration is found for the given ID."
                }
              ],
              "returns": {
                "type": null,
                "description": "The configuration object for the specified instance.",
                "name": null
              }
            }
          },
          {
            "name": "get_instance",
            "signature": "(self, id: str, subclass_of: type[T]) -> T",
            "is_async": false,
            "docstring": {
              "short_description": "Retrieve a configured instance from the registry.",
              "long_description": "Looks up the configuration by ID, retrieves the corresponding class from the registry,\nand creates an instance of that class. The instance must be a subclass of `Providable`\nand of the type specified by `subclass_of`.",
              "params": [
                {
                  "name": "id",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Unique identifier of the instance configuration."
                },
                {
                  "name": "subclass_of",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "The expected base class or interface of the instance (a subclass of `Providable`)."
                }
              ],
              "raises": [
                {
                  "name": "KeyError",
                  "type": "KeyError",
                  "default": null,
                  "is_optional": null,
                  "description": "If configuration for the given `id` is not found, or if the provider key\nin the configuration is not found in the registry."
                }
              ],
              "returns": {
                "type": "T",
                "description": "Instantiated object of the requested type.",
                "name": null
              }
            }
          },
          {
            "name": "get_pipeline",
            "signature": "(self, predictor_id: str) -> Pipe",
            "is_async": false,
            "docstring": {
              "short_description": "Construct a processing pipeline instance.",
              "long_description": "The pipeline is built from the configuration identified by `predictor_id`. It consists of:\n- A configuration for the entire pipeline (of type `PipelineConfig`)\n- A sequence of instantiated `Pipe` objects for each step in the pipeline.\n\nThe pipeline itself is an instance of `Pipeline` (a subclass of `Pipe`), which chains the steps.",
              "params": [
                {
                  "name": "predictor_id",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "The unique identifier of the pipeline configuration."
                }
              ],
              "raises": [
                {
                  "name": "KeyError",
                  "type": "KeyError",
                  "default": null,
                  "is_optional": null,
                  "description": "If the configuration for `predictor_id` is not found, or if the provider key\nin the configuration is not found in the registry."
                }
              ],
              "returns": {
                "type": "Pipe",
                "description": "The constructed pipeline instance (a `Pipeline` object).",
                "name": null
              }
            }
          }
        ]
      }
    ],
    "functions": []
  },
  {
    "module_path": "src.ce.core.dependency_injection.create_registry",
    "module_docstring": {
      "short_description": null,
      "long_description": null,
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [],
    "functions": [
      {
        "name": "create_registry",
        "signature": "() -> Registry",
        "is_async": false,
        "docstring": {
          "short_description": "Creates and configures the default class registry.",
          "long_description": "This function initializes a `Registry` instance and registers essential classes\nrequired for the application's dependency injection system. The registered classes\ninclude integration adapters, data preparers, and AI inference services.\n\nThe following classes are registered:\n- `OTOBOAdapter`: Handles integration with the OTOBO ticket system.\n- `SubjectBodyPreparer`: Prepares subject and body content for ticket processing.\n- `HFLocalAIInferenceService`: Provides local AI inference using Hugging Face models.",
          "params": [],
          "raises": [],
          "returns": {
            "type": "Registry",
            "description": "A configured registry instance with all necessary classes registered.",
            "name": null
          }
        }
      }
    ]
  },
  {
    "module_path": "src.ce.core.dependency_injection.registry",
    "module_docstring": {
      "short_description": null,
      "long_description": null,
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "Registry",
        "docstring": {
          "short_description": "A registry system for managing and retrieving classes that provide specific functionality.",
          "long_description": "This registry allows classes to be registered and later retrieved by their unique keys.\nIt enforces type checking during retrieval to ensure compatibility with expected interfaces.",
          "params": [
            {
              "name": "_registry",
              "type": "list[type[Providable]]",
              "default": null,
              "is_optional": false,
              "description": "Internal list storing registered classes."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "__init__",
            "signature": "(self)",
            "is_async": false,
            "docstring": {
              "short_description": "Initializes an empty registry with no registered classes.",
              "long_description": null,
              "params": [],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "register_all",
            "signature": "(self, instance_classes: list[Type[Providable]]) -> None",
            "is_async": false,
            "docstring": {
              "short_description": "Registers multiple classes in the registry simultaneously.",
              "long_description": null,
              "params": [
                {
                  "name": "instance_classes",
                  "type": "list[Type[Providable]]",
                  "default": null,
                  "is_optional": false,
                  "description": "List of classes to register. Each class must implement the `Providable` interface."
                }
              ],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "register",
            "signature": "(self, instance_class: type[T]) -> None",
            "is_async": false,
            "docstring": {
              "short_description": "Registers a single class in the registry.",
              "long_description": "The class must implement the `Providable` interface which requires:\n- A `get_provider_key()` method returning a unique string identifier.\n- A `get_description()` method returning a descriptive string.",
              "params": [
                {
                  "name": "instance_class",
                  "type": "type[T]",
                  "default": null,
                  "is_optional": false,
                  "description": "The class to register. Must be a subclass of `Providable`."
                }
              ],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "get",
            "signature": "(self, registry_instance_key: str, instance_class: type[T]) -> type[T]",
            "is_async": false,
            "docstring": {
              "short_description": "Retrieves a registered class by its key and validates its type.",
              "long_description": null,
              "params": [
                {
                  "name": "registry_instance_key",
                  "type": "str",
                  "default": null,
                  "is_optional": false,
                  "description": "The unique key identifying the class to retrieve."
                },
                {
                  "name": "instance_class",
                  "type": "type[T]",
                  "default": null,
                  "is_optional": false,
                  "description": "The expected class/interface type for validation."
                }
              ],
              "raises": [
                {
                  "name": "KeyError",
                  "type": "KeyError",
                  "default": null,
                  "is_optional": null,
                  "description": "If no class is registered under the specified key."
                },
                {
                  "name": "TypeError",
                  "type": "TypeError",
                  "default": null,
                  "is_optional": null,
                  "description": "If the registered class is not a subclass of the expected type."
                }
              ],
              "returns": {
                "type": "type[T]",
                "description": "The registered class matching the key.",
                "name": null
              }
            }
          },
          {
            "name": "contains",
            "signature": "(self, registry_instance_key: str) -> bool",
            "is_async": false,
            "docstring": {
              "short_description": "Checks if a key exists in the registry.",
              "long_description": null,
              "params": [
                {
                  "name": "registry_instance_key",
                  "type": "str",
                  "default": null,
                  "is_optional": false,
                  "description": "The key to check."
                }
              ],
              "raises": [],
              "returns": {
                "type": "bool",
                "description": "True if the key exists, False otherwise.",
                "name": null
              }
            }
          },
          {
            "name": "get_registry_types_descriptions",
            "signature": "(self) -> str",
            "is_async": false,
            "docstring": {
              "short_description": "Generates a formatted string listing all registered classes and their descriptions.",
              "long_description": "The output format is:\n`key: description`\nOne entry per line.",
              "params": [],
              "raises": [],
              "returns": {
                "type": "str",
                "description": "Formatted string of all registered keys and descriptions,\nor \"No registered types found.\" if the registry is empty.",
                "name": null
              }
            }
          },
          {
            "name": "get_all_registry_keys",
            "signature": "(self) -> list[str]",
            "is_async": false,
            "docstring": {
              "short_description": "Retrieves all registered keys in the registry.",
              "long_description": null,
              "params": [],
              "raises": [],
              "returns": {
                "type": "list[str]",
                "description": "List of all registered keys.",
                "name": null
              }
            }
          },
          {
            "name": "get_type_from_key",
            "signature": "(self, registry_instance_key: str) -> type[Providable]",
            "is_async": false,
            "docstring": {
              "short_description": "Retrieves the class type associated with a registration key.",
              "long_description": null,
              "params": [
                {
                  "name": "registry_instance_key",
                  "type": "str",
                  "default": null,
                  "is_optional": false,
                  "description": "The key to look up."
                }
              ],
              "raises": [
                {
                  "name": "KeyError",
                  "type": "KeyError",
                  "default": null,
                  "is_optional": null,
                  "description": "If the key is not found in the registry."
                }
              ],
              "returns": {
                "type": "type[Providable]",
                "description": "The class registered under the key.",
                "name": null
              }
            }
          }
        ]
      }
    ],
    "functions": []
  },
  {
    "module_path": "src.ce.core.mixins.registry_providable_instance",
    "module_docstring": {
      "short_description": null,
      "long_description": null,
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "Providable",
        "docstring": {
          "short_description": "Base class for objects that can be provided by a registry.",
          "long_description": "This class provides common functionality for registry-managed objects including\nconfiguration storage, pretty printing of configuration, and provider registration.",
          "params": [
            {
              "name": "console",
              "type": "Console",
              "default": null,
              "is_optional": false,
              "description": "Rich console instance for output formatting."
            },
            {
              "name": "config",
              "type": "ProvidableConfig",
              "default": null,
              "is_optional": false,
              "description": "Configuration object for this instance."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, config: ProvidableConfig, console: Console | None)",
            "is_async": false,
            "docstring": {
              "short_description": "Initializes the instance with configuration and console.",
              "long_description": "Stores the provided configuration and initializes a Rich Console instance if not provided.\nLogs the initialization event and pretty-prints the configuration.",
              "params": [
                {
                  "name": "config",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Configuration object for this instance."
                },
                {
                  "name": "console",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Optional Rich Console instance for output formatting. If not provided,\na new Console instance will be created."
                }
              ],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "get_provider_key",
            "signature": "(cls) -> str",
            "is_async": false,
            "docstring": {
              "short_description": "Return the provider key for the class.",
              "long_description": "This key is used to register and retrieve instances from the registry.",
              "params": [],
              "raises": [],
              "returns": {
                "type": "str",
                "description": "The class name used as the registry key.",
                "name": null
              }
            }
          },
          {
            "name": "get_description",
            "signature": "() -> str",
            "is_async": false,
            "docstring": {
              "short_description": "Return a human readable description for the class.",
              "long_description": "This method should be overridden by subclasses to provide specific descriptions.\nThe base implementation returns a default placeholder message.",
              "params": [],
              "raises": [],
              "returns": {
                "type": "str",
                "description": "Human-readable description of the class.",
                "name": null
              }
            }
          }
        ]
      }
    ],
    "functions": []
  },
  {
    "module_path": "src.ce.core.util.create_json_config_schema",
    "module_docstring": {
      "short_description": "Module for generating the JSON schema of the OpenTicketAI configuration.",
      "long_description": "This module defines the `RootConfig` model, which is a wrapper around the main configuration\nmodel `OpenTicketAIConfig`. The purpose of this wrapper is to facilitate the generation of\na JSON schema that describes the entire configuration structure.\n\nWhen this module is run as a script, it will:\n  1. Generate the JSON schema for the `RootConfig` model.\n  2. Write the schema to a file named `config.schema.json` in the project's root directory.\n\nThe generated schema file can be used for validating configuration files or for providing\nconfiguration autocompletion and documentation in editors.",
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "RootConfig",
        "docstring": {
          "short_description": "Wrapper model used for schema generation.",
          "long_description": "This class serves as a container for the main configuration model of the OpenTicketAI system.\nIt is designed to be used for generating JSON schema representations of the configuration.",
          "params": [
            {
              "name": "`open_ticket_ai`",
              "type": "`OpenTicketAIConfig`",
              "default": null,
              "is_optional": false,
              "description": "The main configuration object containing all\nsettings and parameters for the OpenTicketAI system."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": []
      }
    ],
    "functions": []
  },
  {
    "module_path": "src.ce.core.util.path_util",
    "module_docstring": {
      "short_description": "Utilities for handling file paths within the project.",
      "long_description": "This module provides helper functions for common path operations, particularly\nfor locating important directories in the project structure.",
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [],
    "functions": [
      {
        "name": "find_python_code_root_path",
        "signature": "(project_name: str) -> Path",
        "is_async": false,
        "docstring": {
          "short_description": "Search parent directories for the project root.",
          "long_description": "This function traverses upwards from the current file's directory to locate\nthe root directory of the project identified by the given name.",
          "params": [
            {
              "name": "project_name",
              "type": null,
              "default": null,
              "is_optional": null,
              "description": "The name of the project root directory to find.\nDefaults to 'open_ticket_ai'."
            }
          ],
          "raises": [
            {
              "name": "FileNotFoundError",
              "type": "FileNotFoundError",
              "default": null,
              "is_optional": null,
              "description": "If the project root directory cannot be found in any\nparent directories."
            }
          ],
          "returns": {
            "type": "Path",
            "description": "The absolute path to the project root directory.",
            "name": null
          }
        }
      }
    ]
  },
  {
    "module_path": "src.ce.core.util.pretty_print_config",
    "module_docstring": {
      "short_description": "Module for pretty printing configuration objects.",
      "long_description": "This module provides functionality to display Pydantic configuration models in a\nnicely formatted and syntax highlighted way using the `rich` library. It converts\nPydantic models to YAML format and applies syntax highlighting for improved readability.\n\nFeatures:\n- Converts Pydantic `BaseModel` instances to dictionaries\n- Serializes configuration data to YAML format\n- Applies YAML syntax highlighting using `rich`\n- Prints highlighted output to console",
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [],
    "functions": [
      {
        "name": "pretty_print_config",
        "signature": "(config: BaseModel, console: Console)",
        "is_async": false,
        "docstring": {
          "short_description": "Pretty print a pydantic model using `rich`.",
          "long_description": "This function converts a Pydantic `BaseModel` to a dictionary, serializes it to YAML,\nand prints it to the console using `rich`'s syntax highlighting. The output is formatted\nwith YAML syntax highlighting for improved readability.\n\nThe process involves:\n    1. Converting the Pydantic model to a dictionary using `model_dump()`\n    2. Serializing the dictionary to a YAML string\n    3. Creating a rich `Syntax` object with YAML highlighting\n    4. Printing the highlighted YAML to the console\n\nNote that this function bypasses standard logging and outputs directly to the console\nusing `rich`'s printing capabilities for optimal formatting.",
          "params": [
            {
              "name": "config",
              "type": "BaseModel",
              "default": null,
              "is_optional": false,
              "description": "The Pydantic model configuration to display."
            },
            {
              "name": "console",
              "type": "Console",
              "default": null,
              "is_optional": false,
              "description": "The rich console instance for output rendering."
            }
          ],
          "raises": [
            {
              "name": "TypeError",
              "type": "TypeError",
              "default": null,
              "is_optional": null,
              "description": "If `config` is not a Pydantic BaseModel instance."
            },
            {
              "name": "yaml.YAMLError",
              "type": "yaml.YAMLError",
              "default": null,
              "is_optional": null,
              "description": "If YAML serialization fails due to invalid data."
            }
          ],
          "returns": null
        }
      }
    ]
  },
  {
    "module_path": "src.ce.main",
    "module_docstring": {
      "short_description": "Open Ticket AI CLI entry point.",
      "long_description": "This module provides the command-line interface for the Open Ticket AI application.\nIt configures logging levels and launches the main application.",
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [],
    "functions": [
      {
        "name": "main",
        "signature": "(verbose: bool, debug: bool)",
        "is_async": false,
        "docstring": {
          "short_description": "Configure logging based on CLI options.",
          "long_description": "This function sets the logging level for the application based on the provided command-line flags.\nIt supports two levels of verbosity:\n- `--verbose` for INFO level logging\n- `--debug` for DEBUG level logging\n\nIf no flags are provided, the default logging level is WARNING. The function also configures\nlog formatting and suppresses noisy libraries (e.g., urllib3).",
          "params": [
            {
              "name": "verbose",
              "type": "bool",
              "default": null,
              "is_optional": false,
              "description": "Enable INFO-level logging when True."
            },
            {
              "name": "debug",
              "type": "bool",
              "default": null,
              "is_optional": false,
              "description": "Enable DEBUG-level logging when True."
            }
          ],
          "raises": [],
          "returns": null
        }
      },
      {
        "name": "start",
        "signature": "()",
        "is_async": false,
        "docstring": {
          "short_description": "Initialize the container and start the application.",
          "long_description": "This command performs the following actions:\n1. Configures the dependency injection container\n2. Retrieves the main application instance from the container\n3. Runs the application\n4. Displays a stylized startup banner using `pyfiglet`\n\nThe application follows a dependency injection pattern where all required\ndependencies are resolved through the `DIContainer`.",
          "params": [],
          "raises": [],
          "returns": null
        }
      }
    ]
  },
  {
    "module_path": "src.ce.otobo_integration.otobo_adapter",
    "module_docstring": {
      "short_description": "This module provides an adapter for integrating with the OTOBO ticket system.",
      "long_description": "The `OTOBOAdapter` class implements the `TicketSystemAdapter` interface to enable\nseamless interaction with OTOBO's ticketing API. It handles operations such as:\n\n- Searching for tickets based on custom queries\n- Retrieving specific ticket details\n- Updating existing ticket records\n\nThe adapter uses dependency injection for configuration and client management,\nensuring flexibility and testability.",
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "OTOBOAdapter",
        "docstring": {
          "short_description": "Adapter for integrating with the OTOBO ticket system.",
          "long_description": "Implements the `TicketSystemAdapter` interface to provide methods for:\n- Searching tickets using custom queries\n- Retrieving ticket details\n- Updating ticket records",
          "params": [
            {
              "name": "otobo_client",
              "type": "OTOBOClient",
              "default": null,
              "is_optional": false,
              "description": "Client instance for interacting with the OTOBO API."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "get_description",
            "signature": "() -> str",
            "is_async": false,
            "docstring": {
              "short_description": "Return a description of the adapter's functionality.",
              "long_description": null,
              "params": [],
              "raises": [],
              "returns": {
                "type": "str",
                "description": "A description of the OTOBO adapter.",
                "name": null
              }
            }
          },
          {
            "name": "__init__",
            "signature": "(self, config: SystemConfig, otobo_client: OTOBOClient)",
            "is_async": false,
            "docstring": {
              "short_description": "Initialize the OTOBO adapter with configuration and client.",
              "long_description": null,
              "params": [
                {
                  "name": "config",
                  "type": "SystemConfig",
                  "default": null,
                  "is_optional": false,
                  "description": "System configuration object containing necessary settings."
                },
                {
                  "name": "otobo_client",
                  "type": "OTOBOClient",
                  "default": null,
                  "is_optional": false,
                  "description": "Pre-configured client for interacting with the OTOBO API."
                }
              ],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "find_tickets",
            "signature": "(self, criteria: SearchCriteria) -> list[UnifiedTicket]",
            "is_async": true,
            "docstring": {
              "short_description": "Search for tickets matching the provided criteria.",
              "long_description": "Builds a search query from the criteria and uses the OTOBO client\nto retrieve matching tickets. Returns a list of UnifiedTicket objects.\n\nCurrently, the following criteria attributes are supported:\n  - id: The ticket ID.\n  - subject: The subject of the ticket.",
              "params": [
                {
                  "name": "criteria",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Search parameters describing the desired tickets."
                }
              ],
              "raises": [],
              "returns": {
                "type": "list[UnifiedTicket]",
                "description": "A list of matching tickets. Returns an empty list if none are found.",
                "name": null
              }
            }
          },
          {
            "name": "find_first_ticket",
            "signature": "(self, criteria: SearchCriteria) -> UnifiedTicket | None",
            "is_async": true,
            "docstring": {
              "short_description": "Retrieve the first ticket matching the search criteria.",
              "long_description": "Uses `find_tickets` to get all matching tickets and returns the first result if available.",
              "params": [
                {
                  "name": "criteria",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Search parameters formatted as a :class:`SearchCriteria` instance."
                }
              ],
              "raises": [],
              "returns": {
                "type": "Optional[UnifiedTicket]",
                "description": "The first matching ticket or ``None`` if nothing was found.",
                "name": null
              }
            }
          },
          {
            "name": "update_ticket",
            "signature": "(self, ticket_id: str, updates: dict) -> bool",
            "is_async": true,
            "docstring": {
              "short_description": "Update a ticket record with new data.",
              "long_description": "Validates and merges the ticket ID with update data into `TicketUpdateParams`,\nthen sends the update request to the OTOBO API.",
              "params": [
                {
                  "name": "ticket_id",
                  "type": "str",
                  "default": null,
                  "is_optional": false,
                  "description": "Identifier of the ticket to update."
                },
                {
                  "name": "updates",
                  "type": "dict",
                  "default": null,
                  "is_optional": false,
                  "description": "Key-value pairs representing fields to update and their new values."
                }
              ],
              "raises": [
                {
                  "name": "ValidationError",
                  "type": "ValidationError",
                  "default": null,
                  "is_optional": null,
                  "description": "If `updates` contains invalid fields or values for ticket update."
                }
              ],
              "returns": {
                "type": "bool",
                "description": "``True`` if the update was successful.",
                "name": null
              }
            }
          },
          {
            "name": "create_ticket",
            "signature": "(self, ticket_data: UnifiedTicket) -> UnifiedTicket",
            "is_async": true,
            "docstring": {
              "short_description": "Create a ticket in OTOBO from a UnifiedTicket instance.",
              "long_description": "Converts the provided `UnifiedTicket` into `TicketCreateParams` and sends the creation request\nto the OTOBO API. The returned ticket will have the `id` field updated to the ID assigned by OTOBO.",
              "params": [
                {
                  "name": "ticket_data",
                  "type": "UnifiedTicket",
                  "default": null,
                  "is_optional": false,
                  "description": "The ticket data to create."
                }
              ],
              "raises": [],
              "returns": {
                "type": "UnifiedTicket",
                "description": "The created ticket data with the `id` field updated to the new ticket ID.",
                "name": null
              }
            }
          },
          {
            "name": "add_note",
            "signature": "(self, ticket_id: str, note: UnifiedNote) -> UnifiedNote",
            "is_async": true,
            "docstring": {
              "short_description": "Add a note to a ticket.",
              "long_description": "Note: The public OTOBO client does not currently expose an endpoint for creating articles (notes).\nTherefore, this method does not actually create a note in OTOBO and instead returns the provided note.",
              "params": [
                {
                  "name": "ticket_id",
                  "type": "str",
                  "default": null,
                  "is_optional": false,
                  "description": "The ID of the ticket to which the note should be added."
                },
                {
                  "name": "note",
                  "type": "UnifiedNote",
                  "default": null,
                  "is_optional": false,
                  "description": "The note to add."
                }
              ],
              "raises": [],
              "returns": {
                "type": "UnifiedNote",
                "description": "The same note that was passed in.",
                "name": null
              }
            }
          }
        ]
      }
    ],
    "functions": []
  },
  {
    "module_path": "src.ce.otobo_integration.unified_models",
    "module_docstring": {
      "short_description": "Public interface for unified models in the ticket system integration.",
      "long_description": "This module imports all public classes, functions, and variables from the unified_models module\n(located in the parent package's `ticket_system_integration` package) using a wildcard import.\nThis provides convenient access to the unified models without requiring explicit imports.\n\n## Purpose\nProvides a single import point for accessing all unified ticket system models, simplifying\nintegration code and reducing import boilerplate throughout the application.\n\n## Usage\nImport this module to access all unified ticket system models:",
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [],
    "functions": []
  },
  {
    "module_path": "src.ce.run.managers.orchestrator",
    "module_docstring": {
      "short_description": "Top level orchestration utilities.",
      "long_description": null,
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "Orchestrator",
        "docstring": {
          "short_description": "Orchestrates the execution of ticket processing pipelines.",
          "long_description": "This class manages the lifecycle of pipelines including:\n- Pipeline instantiation via dependency injection\n- Individual ticket processing\n- Scheduled execution of pipelines",
          "params": [
            {
              "name": "config",
              "type": null,
              "default": null,
              "is_optional": null,
              "description": "Configuration settings for the orchestrator"
            },
            {
              "name": "container",
              "type": null,
              "default": null,
              "is_optional": null,
              "description": "Dependency injection container providing pipeline instances"
            },
            {
              "name": "_logger",
              "type": null,
              "default": null,
              "is_optional": null,
              "description": "Logger instance for orchestration operations"
            },
            {
              "name": "_pipelines",
              "type": null,
              "default": null,
              "is_optional": null,
              "description": "Dictionary mapping pipeline IDs to pipeline instances"
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, config: OpenTicketAIConfig, container: AbstractContainer)",
            "is_async": false,
            "docstring": {
              "short_description": "Initialize the Orchestrator with configuration and DI container.",
              "long_description": null,
              "params": [
                {
                  "name": "config",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Configuration settings for the orchestrator."
                },
                {
                  "name": "container",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Dependency injection container providing pipeline instances."
                }
              ],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "process_ticket",
            "signature": "(self, ticket_id: str, pipeline: Pipeline) -> PipelineContext",
            "is_async": false,
            "docstring": {
              "short_description": "Executes a pipeline for a specific ticket.",
              "long_description": "Creates a processing context and runs the specified pipeline to process\nthe given ticket. This is the core method for individual ticket processing.",
              "params": [
                {
                  "name": "ticket_id",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Unique identifier of the ticket to process."
                },
                {
                  "name": "pipeline",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Pipeline instance to execute."
                }
              ],
              "raises": [],
              "returns": {
                "type": "PipelineContext",
                "description": "The execution context containing results and state\nafter pipeline execution.",
                "name": null
              }
            }
          },
          {
            "name": "build_pipelines",
            "signature": "(self) -> None",
            "is_async": false,
            "docstring": {
              "short_description": "Instantiates all configured pipeline objects.",
              "long_description": "Uses the dependency injection container to create pipeline instances\nbased on the configuration. Populates the internal pipeline registry\nwith pipeline ID to instance mappings.",
              "params": [],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "set_schedules",
            "signature": "(self) -> None",
            "is_async": false,
            "docstring": {
              "short_description": "Configures scheduled execution for all pipelines.",
              "long_description": "Performs the following operations:\n1. Builds pipelines if not already instantiated\n2. Configures periodic execution for each pipeline according to its\n   schedule configuration using the `schedule` library\n\nThe scheduling uses the following configuration parameters:\n- interval: Numeric interval value\n- unit: Time unit (e.g., minutes, hours, days)\n\nNote:\n- Uses `schedule.every(interval).unit` pattern for scheduling\n- Passes an empty ticket_id context during scheduled executions",
              "params": [],
              "raises": [],
              "returns": null
            }
          }
        ]
      }
    ],
    "functions": []
  },
  {
    "module_path": "src.ce.run.pipe_implementations.ai_text_model_input",
    "module_docstring": {
      "short_description": null,
      "long_description": null,
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "TextAIModelInput",
        "docstring": {
          "short_description": "Context for the input to the Hugging Face inference service.",
          "long_description": "This class is used to encapsulate the input data and any additional parameters\nrequired for the inference request.",
          "params": [
            {
              "name": "ai_model_input",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "The input text provided to the AI model for processing.\nRepresents the primary data payload for the inference request."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": []
      }
    ],
    "functions": []
  },
  {
    "module_path": "src.ce.run.pipe_implementations.empty_data_model",
    "module_docstring": {
      "short_description": null,
      "long_description": null,
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "EmptyDataModel",
        "docstring": {
          "short_description": "Empty Pydantic model without any fields.",
          "long_description": "This model serves as a placeholder for scenarios requiring a Pydantic-compatible\nobject but without any data fields. It can be used as a base class or type hint\nwhen no specific data structure is needed.",
          "params": [],
          "raises": [],
          "returns": null
        },
        "methods": []
      }
    ],
    "functions": []
  },
  {
    "module_path": "src.ce.run.pipe_implementations.generic_ticket_updater.generic_ticket_updater",
    "module_docstring": {
      "short_description": null,
      "long_description": null,
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "GenericTicketUpdater",
        "docstring": {
          "short_description": "Updates tickets in external systems using pipeline-generated data.",
          "long_description": "This component updates tickets in external ticket tracking systems (e.g., Jira, ServiceNow)\nusing data generated during pipeline execution. It checks the pipeline context for update\ninstructions and delegates the update operation to the configured ticket system adapter.\n\n`Attributes`:\n    modifier_config: Configuration settings for the ticket updater.\n    ticket_system: Adapter instance for interacting with the external ticket system.",
          "params": [],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, config: ProvidableConfig, ticket_system: TicketSystemAdapter)",
            "is_async": false,
            "docstring": {
              "short_description": "Initializes the `GenericTicketUpdater` with configuration and ticket system adapter.",
              "long_description": "`Args`:\n    config: Configuration instance containing settings for the pipeline component.\n    ticket_system: Adapter object that handles communication with the external ticket system.",
              "params": [],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "process",
            "signature": "(self, context: PipelineContext[UnifiedTicket]) -> PipelineContext[EmptyDataModel]",
            "is_async": false,
            "docstring": {
              "short_description": "Updates the ticket in the external system if update data exists.",
              "long_description": "Retrieves update data from `context.data` (of type `UnifiedTicket`) and updates the ticket\nin the ticket system when update data is present. Returns the context unchanged after processing.\n\n`Args`:\n    context: Pipeline context containing data and ticket information.\n\n`Returns`:\n    The original pipeline context after processing (unchanged).\n\n`Example`:\n    ```python\n    context = PipelineContext(ticket_id=\"TICKET-123\", data=update_data)\n    updater.process(context)  # Updates ticket if update_data exists\n    ```",
              "params": [],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "get_description",
            "signature": "() -> str",
            "is_async": false,
            "docstring": {
              "short_description": "Provides a description of the pipe's purpose.",
              "long_description": "`Returns`:\n    A string describing the pipe's functionality.",
              "params": [],
              "raises": [],
              "returns": null
            }
          }
        ]
      }
    ],
    "functions": []
  },
  {
    "module_path": "src.ce.run.pipe_implementations.hf_inference_services.hf_cloud_inference_service",
    "module_docstring": {
      "short_description": null,
      "long_description": null,
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "HFLocalAIInferenceService",
        "docstring": {
          "short_description": "A Hugging Face local AI inference service implementation.",
          "long_description": "This class provides functionality to run inference using Hugging Face models\nlocally. It processes text inputs from pipeline context data and stores\ninference results back in the context.",
          "params": [
            {
              "name": "ai_inference_config",
              "type": "ProvidableConfig",
              "default": null,
              "is_optional": false,
              "description": "Configuration for the service."
            },
            {
              "name": "input_field",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "Key in context data for input text."
            },
            {
              "name": "result_field",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "Key in context data to store inference results."
            },
            {
              "name": "model_name",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "Name of the Hugging Face model to use."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, config: ProvidableConfig)",
            "is_async": false,
            "docstring": {
              "short_description": "Initializes the Hugging Face local inference service.",
              "long_description": null,
              "params": [
                {
                  "name": "config",
                  "type": "ProvidableConfig",
                  "default": null,
                  "is_optional": false,
                  "description": "Configuration instance containing service parameters."
                }
              ],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "process",
            "signature": "(self, context: PipelineContext) -> PipelineContext",
            "is_async": false,
            "docstring": {
              "short_description": "Processes pipeline context by running Hugging Face model inference.",
              "long_description": "Retrieves input text from context data, runs model inference, and stores\nthe result back in context data under the configured result field.",
              "params": [
                {
                  "name": "context",
                  "type": "PipelineContext",
                  "default": null,
                  "is_optional": false,
                  "description": "Pipeline context containing data to process."
                }
              ],
              "raises": [
                {
                  "name": "KeyError",
                  "type": "KeyError",
                  "default": null,
                  "is_optional": null,
                  "description": "If the input field is missing from context data."
                }
              ],
              "returns": {
                "type": "PipelineContext",
                "description": "Updated context with inference results stored.",
                "name": null
              }
            }
          },
          {
            "name": "get_description",
            "signature": "() -> str",
            "is_async": false,
            "docstring": {
              "short_description": "Provides a description of the service.",
              "long_description": null,
              "params": [],
              "raises": [],
              "returns": {
                "type": "str",
                "description": "Description text for the Hugging Face AI model service.",
                "name": null
              }
            }
          }
        ]
      }
    ],
    "functions": []
  },
  {
    "module_path": "src.ce.run.pipe_implementations.hf_inference_services.hf_local_ai_inference_service",
    "module_docstring": {
      "short_description": "Module for Hugging Face local AI inference service implementation.",
      "long_description": "This module provides a pipeline component (Pipe) for running Hugging Face models locally\nfor text classification tasks within a processing pipeline.",
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "HFLocalAIInferenceService",
        "docstring": {
          "short_description": "A Hugging Face local AI inference service for text classification.",
          "long_description": "This class uses the Hugging Face transformers library to run a local model for text classification.\nIt is designed to be used as a pipe in a pipeline.",
          "params": [
            {
              "name": "ai_inference_config",
              "type": "ProvidableConfig",
              "default": null,
              "is_optional": false,
              "description": "The configuration for the service."
            },
            {
              "name": "input_field",
              "type": "str",
              "default": "\"prepared_data\"",
              "is_optional": false,
              "description": "The key in the context data to use as input text. Defaults to \"prepared_data\"."
            },
            {
              "name": "result_field",
              "type": "str",
              "default": "\"model_result\"",
              "is_optional": false,
              "description": "The key in the context data to store the result. Defaults to \"model_result\"."
            },
            {
              "name": "model_name",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "The name of the Hugging Face model to use."
            },
            {
              "name": "tokenizer",
              "type": "AutoTokenizer",
              "default": null,
              "is_optional": false,
              "description": "The tokenizer for the model."
            },
            {
              "name": "_pipeline",
              "type": "Pipeline",
              "default": null,
              "is_optional": false,
              "description": "The Hugging Face pipeline for text classification."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, config: ProvidableConfig)",
            "is_async": false,
            "docstring": {
              "short_description": "Initializes the HFLocalAIInferenceService with configuration.",
              "long_description": "Sets up the tokenizer and pipeline for the specified Hugging Face model.",
              "params": [
                {
                  "name": "config",
                  "type": "ProvidableConfig",
                  "default": null,
                  "is_optional": false,
                  "description": "Configuration instance for the service. Expected to have:\n- params: A dictionary containing:\n* \"input_field\": (str, optional) The key in the context data for input text. Defaults to \"prepared_data\".\n* \"result_field\": (str, optional) The key to store the result in the context data. Defaults to \"model_result\".\n* \"hf_model\": (str) The name of the Hugging Face model.\n* \"hf_token_env_var\": (str, optional) The environment variable name for the Hugging Face token."
                }
              ],
              "raises": [
                {
                  "name": "KeyError",
                  "type": "KeyError",
                  "default": null,
                  "is_optional": null,
                  "description": "If the required parameter \"hf_model\" is not provided."
                }
              ],
              "returns": null
            }
          },
          {
            "name": "process",
            "signature": "(self, context: PipelineContext) -> PipelineContext",
            "is_async": false,
            "docstring": {
              "short_description": "Runs the Hugging Face text classification pipeline on the input text from the context.",
              "long_description": "The input text is taken from the context's data using the key specified by `input_field`.\nThe result of the pipeline (a list of dictionaries) is stored in the context's data under the key `result_field`.",
              "params": [
                {
                  "name": "context",
                  "type": "PipelineContext",
                  "default": null,
                  "is_optional": false,
                  "description": "The pipeline context containing the data to process."
                }
              ],
              "raises": [],
              "returns": {
                "type": "PipelineContext",
                "description": "The updated context with the model result stored in the data.",
                "name": null
              }
            }
          },
          {
            "name": "get_description",
            "signature": "() -> str",
            "is_async": false,
            "docstring": {
              "short_description": "Provides a description of the service.",
              "long_description": null,
              "params": [],
              "raises": [],
              "returns": {
                "type": "str",
                "description": "Description text for the Hugging Face AI model service.",
                "name": null
              }
            }
          }
        ]
      }
    ],
    "functions": []
  },
  {
    "module_path": "src.ce.run.pipe_implementations.hf_local_ai_inference_service",
    "module_docstring": {
      "short_description": null,
      "long_description": null,
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "HFLocalAIInferenceService",
        "docstring": {
          "short_description": "A pipeline component for Hugging Face model inference.",
          "long_description": "This class implements a Pipe for running text classification using a pre-trained\nHugging Face model. It handles model loading, tokenization, and inference execution.",
          "params": [
            {
              "name": "ai_inference_config",
              "type": "ProvidableConfig",
              "default": null,
              "is_optional": false,
              "description": "Configuration for the inference service."
            },
            {
              "name": "input_field",
              "type": "str",
              "default": "\"prepared_data\"",
              "is_optional": false,
              "description": "Key in context data containing input text. Defaults to \"prepared_data\"."
            },
            {
              "name": "result_field",
              "type": "str",
              "default": "\"model_result\"",
              "is_optional": false,
              "description": "Key to store inference results in context data. Defaults to \"model_result\"."
            },
            {
              "name": "model_name",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "Name of the Hugging Face model to load."
            },
            {
              "name": "tokenizer",
              "type": "AutoTokenizer",
              "default": null,
              "is_optional": false,
              "description": "Tokenizer for the specified model."
            },
            {
              "name": "_pipeline",
              "type": "Pipeline",
              "default": null,
              "is_optional": false,
              "description": "Hugging Face text classification pipeline."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, config: ProvidableConfig)",
            "is_async": false,
            "docstring": {
              "short_description": "Initializes the Hugging Face inference service with configuration.",
              "long_description": "Loads model and tokenizer, and creates a text-classification pipeline. Authentication\ntoken is retrieved from environment variables if specified in configuration.",
              "params": [
                {
                  "name": "config",
                  "type": "ProvidableConfig",
                  "default": null,
                  "is_optional": false,
                  "description": "Configuration object containing a `params` dictionary\nwith the following keys:\n- `hf_model` (str): Required model identifier (e.g., \"distilbert-base-uncased\").\n- `input_field` (str, optional): Key for input text in context data. Defaults to \"prepared_data\".\n- `result_field` (str, optional): Key for storing results. Defaults to \"model_result\".\n- `hf_token_env_var` (str, optional): Environment variable name for Hugging Face token."
                }
              ],
              "raises": [
                {
                  "name": "KeyError",
                  "type": "KeyError",
                  "default": null,
                  "is_optional": null,
                  "description": "If required 'hf_model' parameter is missing."
                },
                {
                  "name": "EnvironmentError",
                  "type": "EnvironmentError",
                  "default": null,
                  "is_optional": null,
                  "description": "If token environment variable is specified but not set."
                }
              ],
              "returns": null
            }
          },
          {
            "name": "process",
            "signature": "(self, context: PipelineContext) -> PipelineContext",
            "is_async": false,
            "docstring": {
              "short_description": "Runs model inference on input text and stores results.",
              "long_description": "This method retrieves the input text from the context using the key specified by `input_field`,\nruns the text classification pipeline on the text, and stores the result in the context under\nthe key specified by `result_field`.",
              "params": [
                {
                  "name": "context",
                  "type": "PipelineContext",
                  "default": null,
                  "is_optional": false,
                  "description": "Pipeline context containing data dictionary."
                }
              ],
              "raises": [],
              "returns": {
                "type": "PipelineContext",
                "description": "Updated context with inference results stored under `result_field`.",
                "name": null
              }
            }
          },
          {
            "name": "get_description",
            "signature": "() -> str",
            "is_async": false,
            "docstring": {
              "short_description": "Provides a description of the service.",
              "long_description": null,
              "params": [],
              "raises": [],
              "returns": {
                "type": "str",
                "description": "Description text for the Hugging Face AI model service.",
                "name": null
              }
            }
          }
        ]
      }
    ],
    "functions": []
  },
  {
    "module_path": "src.ce.run.pipe_implementations.subject_body_preparer.subject_body_preparer",
    "module_docstring": {
      "short_description": "Module containing the SubjectBodyPreparer pipeline component for ticket processing.",
      "long_description": null,
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "SubjectBodyPreparer",
        "docstring": {
          "short_description": "A pipeline component that prepares ticket subject and body content for processing.",
          "long_description": "This pipe extracts the subject and body fields from ticket data, repeats the subject\na configurable number of times, and concatenates it with the body content. The prepared\ndata is stored in the pipeline context for downstream processing.",
          "params": [
            {
              "name": "preparer_config",
              "type": "ProvidableConfig",
              "default": null,
              "is_optional": false,
              "description": "Configuration parameters for the preparer."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, config: ProvidableConfig)",
            "is_async": false,
            "docstring": {
              "short_description": "Initializes the SubjectBodyPreparer with configuration.",
              "long_description": null,
              "params": [
                {
                  "name": "config",
                  "type": "ProvidableConfig",
                  "default": null,
                  "is_optional": false,
                  "description": "Configuration parameters for the preparer."
                }
              ],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "process",
            "signature": "(self, context: PipelineContext) -> PipelineContext",
            "is_async": false,
            "docstring": {
              "short_description": "Processes ticket data to prepare subject and body content.",
              "long_description": "Extracts the configured subject and body fields from context data,\nrepeats the subject as specified in configuration, concatenates it with\nthe body and stores the result in the configured result field.\n\nConfiguration parameters (with defaults if not provided):\n  - `subject_field` (str): Key for subject in context data (default: `\"subject\"`)\n  - `body_field` (str): Key for body in context data (default: `\"body\"`)\n  - `repeat_subject` (int): Number of times to repeat subject (default: `3`)\n  - `result_field` (str): Key to store prepared result (default: `\"subject_body_combined\"`)",
              "params": [
                {
                  "name": "context",
                  "type": "PipelineContext",
                  "default": null,
                  "is_optional": false,
                  "description": "Pipeline context containing ticket data."
                }
              ],
              "raises": [
                {
                  "name": "ValueError",
                  "type": "ValueError",
                  "default": null,
                  "is_optional": null,
                  "description": "If `repeat_subject` configuration parameter cannot be converted to integer."
                }
              ],
              "returns": {
                "type": "PipelineContext",
                "description": "Updated context with prepared data stored under `result_field`.",
                "name": null
              }
            }
          },
          {
            "name": "get_description",
            "signature": "() -> str",
            "is_async": false,
            "docstring": {
              "short_description": "Provides a description of the pipe's functionality.",
              "long_description": null,
              "params": [],
              "raises": [],
              "returns": {
                "type": "str",
                "description": "Description of the pipe's purpose.",
                "name": null
              }
            }
          }
        ]
      }
    ],
    "functions": []
  },
  {
    "module_path": "src.ce.run.pipe_implementations.ticket_fetcher.basic_ticket_fetcher",
    "module_docstring": {
      "short_description": null,
      "long_description": null,
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "BasicTicketFetcher",
        "docstring": {
          "short_description": "Simple fetcher that loads ticket data using the ticket system adapter.",
          "long_description": "This pipe retrieves ticket information from an external ticket system using\nthe provided adapter. It serves as a placeholder for more complex fetching\nimplementations.",
          "params": [
            {
              "name": "fetcher_config",
              "type": "`open_ticket_ai.src.ce.core.config.config_models.ProvidableConfig`",
              "default": null,
              "is_optional": false,
              "description": "Configuration instance for the fetcher."
            },
            {
              "name": "ticket_system",
              "type": "`TicketSystemAdapter`",
              "default": null,
              "is_optional": false,
              "description": "Adapter for interacting with the ticket system."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, config: ProvidableConfig, ticket_system: TicketSystemAdapter)",
            "is_async": false,
            "docstring": {
              "short_description": "Initializes the BasicTicketFetcher with configuration and ticket system adapter.",
              "long_description": null,
              "params": [
                {
                  "name": "config",
                  "type": "`open_ticket_ai.src.ce.core.config.config_models.ProvidableConfig`",
                  "default": null,
                  "is_optional": false,
                  "description": "The configuration instance for the fetcher."
                },
                {
                  "name": "ticket_system",
                  "type": "`TicketSystemAdapter`",
                  "default": null,
                  "is_optional": false,
                  "description": "The adapter for interacting with the ticket system."
                }
              ],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "process",
            "signature": "(self, context: PipelineContext) -> PipelineContext",
            "is_async": false,
            "docstring": {
              "short_description": "Fetch ticket data using configured filters and update the context.",
              "long_description": "The fetcher reads optional `filters` from its configuration. Each filter\ncontains an `attribute` and `value` entry. Attributes must map to\nfields supported by `SearchCriteria`. Unsupported attributes\nresult in a controlled pipeline stop.\n\nIf no filters are provided, the `ticket_id` from the context is used as\nthe search criterion. When no ticket is found, the pipeline is stopped.",
              "params": [
                {
                  "name": "context",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "The current `PipelineContext`."
                }
              ],
              "raises": [],
              "returns": {
                "type": null,
                "description": "The updated context or the original context if the pipeline was\nstopped.",
                "name": null
              }
            }
          },
          {
            "name": "get_description",
            "signature": "() -> str",
            "is_async": false,
            "docstring": {
              "short_description": "Provides a static description of this pipe's functionality.",
              "long_description": null,
              "params": [],
              "raises": [],
              "returns": {
                "type": "str",
                "description": "A static description of the pipe's purpose and behavior.",
                "name": null
              }
            }
          }
        ]
      }
    ],
    "functions": []
  },
  {
    "module_path": "src.ce.run.pipeline.context",
    "module_docstring": {
      "short_description": null,
      "long_description": null,
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "PipelineContext",
        "docstring": {
          "short_description": "Context object passed between pipeline stages.",
          "long_description": "This generic class serves as a container for sharing state and data across\ndifferent stages of a processing pipeline. It leverages Pydantic for data\nvalidation and serialization.\n\nThe generic type parameter `DataT` must be a subclass of `BaseModel`,\nensuring type safety for the main data payload.",
          "params": [
            {
              "name": "data",
              "type": "DataT",
              "default": null,
              "is_optional": false,
              "description": "The main data payload being processed through the pipeline.\nMust be a Pydantic model instance matching the generic type."
            },
            {
              "name": "meta_info",
              "type": "MetaInfo",
              "default": null,
              "is_optional": false,
              "description": "Metadata about the pipeline execution, including\nstatus information and operational details."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "stop_pipeline",
            "signature": "(self)",
            "is_async": false,
            "docstring": {
              "short_description": "Signals the pipeline to halt processing.",
              "long_description": "This method provides a controlled way for pipeline stages to indicate\nthat processing should stop. It updates the context's status metadata\nto `STOPPED`, which subsequent stages can check to terminate early.\n\nNote:\n    This method modifies the context's state but does not return any value.",
              "params": [],
              "raises": [],
              "returns": null
            }
          }
        ]
      }
    ],
    "functions": []
  },
  {
    "module_path": "src.ce.run.pipeline.meta_info",
    "module_docstring": {
      "short_description": null,
      "long_description": null,
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "MetaInfo",
        "docstring": {
          "short_description": "Stores metadata about the pipeline execution state.",
          "long_description": "This model captures the current status of a pipeline along with any error\ninformation when failures occur.",
          "params": [
            {
              "name": "status",
              "type": null,
              "default": "RUNNING",
              "is_optional": null,
              "description": "Current execution status of the pipeline. Defaults to RUNNING."
            },
            {
              "name": "error_message",
              "type": null,
              "default": null,
              "is_optional": null,
              "description": "Detailed error message if the pipeline failed. None if successful."
            },
            {
              "name": "failed_pipe",
              "type": null,
              "default": null,
              "is_optional": null,
              "description": "Identifier of the specific pipe that caused failure. None if successful."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": []
      }
    ],
    "functions": []
  },
  {
    "module_path": "src.ce.run.pipeline.pipe",
    "module_docstring": {
      "short_description": null,
      "long_description": null,
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "Pipe",
        "docstring": {
          "short_description": "Interface for all pipeline components.",
          "long_description": "This abstract base class defines the common interface that all pipeline\ncomponents must implement. It inherits from `Providable`\nto enable automatic registration in a component registry and from `ABC`\nto enforce abstract method implementation.\n\nSubclasses must implement the `process` method to define their specific\ndata transformation logic within the pipeline.\n\nAttributes:\n    Inherits attributes from `Providable` for registry management.\n    InputDataType (type[InputDataT]): The type of the input data model \n        expected by this pipe component.\n    OutputDataType (type[OutputDataT]): The type of the output data model \n        produced by this pipe component.",
          "params": [],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "process",
            "signature": "(self, context: PipelineContext[InputDataT]) -> PipelineContext[OutputDataT]",
            "is_async": false,
            "docstring": {
              "short_description": "Process a pipeline context object and return the modified context.",
              "long_description": "This method defines the core processing logic for a pipeline component.\nIt takes a `PipelineContext` object containing shared pipeline state,\nperforms transformations or operations on this context, and returns the\nupdated context for the next component in the pipeline.\n\nArgs:\n    context: The current pipeline context containing shared state data.\n\nReturns:\n    The updated `PipelineContext` object after processing.\n\nRaises:\n    Implementation-specific exceptions may be raised by subclasses to\n    indicate processing errors or invalid states.",
              "params": [],
              "raises": [],
              "returns": null
            }
          }
        ]
      }
    ],
    "functions": []
  },
  {
    "module_path": "src.ce.run.pipeline.pipeline",
    "module_docstring": {
      "short_description": "Defines the Pipeline class for executing a sequence of pipes.",
      "long_description": "The Pipeline is a specialized Pipe that runs multiple pipes in sequence. It manages the context\nand status throughout the execution, handling errors and stop requests appropriately.",
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "Pipeline",
        "docstring": {
          "short_description": "A pipeline that executes a sequence of pipes sequentially.",
          "long_description": "This class manages the execution flow of multiple pipes, handling status transitions,\nerror propagation, and stop requests during processing.",
          "params": [
            {
              "name": "pipes",
              "type": null,
              "default": null,
              "is_optional": null,
              "description": "List of Pipe objects to execute in sequence."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, config: PipelineConfig, pipes: List[Pipe])",
            "is_async": false,
            "docstring": {
              "short_description": "Initializes the Pipeline with configuration and pipe sequence.",
              "long_description": null,
              "params": [
                {
                  "name": "config",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Configuration settings for the pipeline."
                },
                {
                  "name": "pipes",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Ordered list of Pipe instances to execute."
                }
              ],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "execute",
            "signature": "(self, context: PipelineContext) -> PipelineContext",
            "is_async": false,
            "docstring": {
              "short_description": "Executes all pipes sequentially with error handling and status propagation.",
              "long_description": "Processes each pipe in sequence while:\n- Validating input data using each pipe's input model\n- Handling STOPPED status requests from pipes\n- Catching and logging exceptions during pipe execution\n- Updating context status appropriately (RUNNING, SUCCESS, FAILED, STOPPED)",
              "params": [
                {
                  "name": "context",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "The pipeline context containing execution state and data."
                }
              ],
              "raises": [],
              "returns": {
                "type": null,
                "description": "Updated PipelineContext reflecting final execution state after processing.",
                "name": null
              }
            }
          },
          {
            "name": "process",
            "signature": "(self, context: PipelineContext) -> PipelineContext",
            "is_async": false,
            "docstring": {
              "short_description": "Processes context through the entire pipeline sequence.",
              "long_description": "Implements the abstract method from the Pipe base class. Delegates to\nthe `execute()` method for actual pipeline processing.",
              "params": [
                {
                  "name": "context",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "The pipeline context containing execution state and data."
                }
              ],
              "raises": [],
              "returns": {
                "type": null,
                "description": "Updated PipelineContext after processing through all pipes.",
                "name": null
              }
            }
          }
        ]
      }
    ],
    "functions": []
  },
  {
    "module_path": "src.ce.run.pipeline.status",
    "module_docstring": {
      "short_description": null,
      "long_description": null,
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "PipelineStatus",
        "docstring": {
          "short_description": "Represents the possible states of a pipeline execution.",
          "long_description": "This enum defines the various statuses a pipeline can have during its lifecycle.",
          "params": [
            {
              "name": "RUNNING",
              "type": null,
              "default": null,
              "is_optional": null,
              "description": "Indicates the pipeline is currently executing."
            },
            {
              "name": "SUCCESS",
              "type": null,
              "default": null,
              "is_optional": null,
              "description": "Indicates the pipeline completed successfully without errors."
            },
            {
              "name": "STOPPED",
              "type": null,
              "default": null,
              "is_optional": null,
              "description": "Indicates the pipeline was intentionally halted (controlled stop)."
            },
            {
              "name": "FAILED",
              "type": null,
              "default": null,
              "is_optional": null,
              "description": "Indicates the pipeline terminated due to an unexpected error."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": []
      }
    ],
    "functions": []
  },
  {
    "module_path": "src.ce.ticket_system_integration.otobo_adapter",
    "module_docstring": {
      "short_description": "Package for integrating with OTOBO systems.",
      "long_description": "This module provides the primary interface for OTOBO integration by exposing\nthe `OTOBOAdapter` class. It serves as the public API entry point for\ninteracting with OTOBO services.",
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [],
    "functions": []
  },
  {
    "module_path": "src.ce.ticket_system_integration.otobo_adapter_config",
    "module_docstring": {
      "short_description": "Configuration model for the OTOBO adapter.",
      "long_description": "This module defines a Pydantic-based configuration model for interacting with an OTOBO server.\nIt includes settings for server connection, web service operations, and authentication.\nThe model validates configuration data and securely retrieves sensitive information from environment variables.",
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "OTOBOAdapterConfig",
        "docstring": {
          "short_description": "Configuration model for OTOBO adapter.",
          "long_description": "This model defines the necessary configuration parameters to connect and interact with an OTOBO server.\nIt includes server details, web service endpoints, and authentication credentials.",
          "params": [
            {
              "name": "server_address",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "The base URL of the OTOBO server."
            },
            {
              "name": "webservice_name",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "The name of the web service to use."
            },
            {
              "name": "search_operation_url",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "The URL for the search operation."
            },
            {
              "name": "update_operation_url",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "The URL for the update operation."
            },
            {
              "name": "get_operation_url",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "The URL for the get operation."
            },
            {
              "name": "username",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "The username for authentication."
            },
            {
              "name": "password_env_var",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "The environment variable that contains the password."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "__str__",
            "signature": "(self)",
            "is_async": false,
            "docstring": {
              "short_description": "Return a string representation of the configuration.",
              "long_description": "The representation excludes the password for security reasons.",
              "params": [],
              "raises": [],
              "returns": {
                "type": "`str`",
                "description": "A formatted string containing the configuration details (excluding password).",
                "name": null
              }
            }
          },
          {
            "name": "password",
            "signature": "(self) -> str",
            "is_async": false,
            "docstring": {
              "short_description": "Retrieves the password from the environment variable specified in the configuration.",
              "long_description": null,
              "params": [],
              "raises": [
                {
                  "name": "`ValueError`",
                  "type": "`ValueError`",
                  "default": null,
                  "is_optional": null,
                  "description": "If the specified environment variable is not set."
                }
              ],
              "returns": {
                "type": "`str`",
                "description": "The password for authentication.",
                "name": null
              }
            }
          }
        ]
      }
    ],
    "functions": []
  },
  {
    "module_path": "src.ce.ticket_system_integration.ticket_system_adapter",
    "module_docstring": {
      "short_description": null,
      "long_description": null,
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "TicketSystemAdapter",
        "docstring": {
          "short_description": "An abstract base class for ticket system adapters.",
          "long_description": "This class defines the interface that all concrete ticket system adapters must\nimplement to interact with different ticketing systems. It provides common\nconfiguration handling through dependency injection and requires subclasses\nto implement core ticket operations.",
          "params": [
            {
              "name": "config",
              "type": "SystemConfig",
              "default": null,
              "is_optional": false,
              "description": "System configuration object containing adapter settings."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, config: SystemConfig)",
            "is_async": false,
            "docstring": {
              "short_description": "Initialize the adapter with system configuration.",
              "long_description": "This constructor is automatically injected with the system configuration\nusing the dependency injection framework. It initializes the adapter\nwith the provided configuration and ensures proper setup of inherited\ncomponents.",
              "params": [
                {
                  "name": "config",
                  "type": "SystemConfig",
                  "default": null,
                  "is_optional": false,
                  "description": "The system configuration object containing\nall necessary settings and parameters for the adapter."
                }
              ],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "update_ticket",
            "signature": "(self, ticket_id: str, updates: dict) -> bool",
            "is_async": true,
            "docstring": {
              "short_description": "Update a ticket in the system.",
              "long_description": "This method must be implemented by concrete adapters to handle updating\nticket attributes in the target ticketing system. It should support partial\nupdates and return the updated ticket representation.",
              "params": [
                {
                  "name": "ticket_id",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Unique identifier of the ticket to update."
                },
                {
                  "name": "updates",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Dictionary of attributes to update on the ticket."
                }
              ],
              "raises": [],
              "returns": {
                "type": "bool",
                "description": "``True`` if the update succeeded, otherwise ``False``.",
                "name": null
              }
            }
          },
          {
            "name": "find_tickets",
            "signature": "(self, criteria: SearchCriteria) -> list[UnifiedTicket]",
            "is_async": true,
            "docstring": {
              "short_description": "Search for tickets matching ``criteria``.",
              "long_description": "This method must be implemented by concrete adapters to perform\ncomplex searches against the target ticketing system. The query\nstructure is adapter-specific but should support common filtering\nand search operations.",
              "params": [
                {
                  "name": "criteria",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Parameters defining which tickets to search for."
                }
              ],
              "raises": [],
              "returns": {
                "type": "list[UnifiedTicket]",
                "description": "A list of tickets that match the criteria.\nReturns an empty list if no matches are found.",
                "name": null
              }
            }
          },
          {
            "name": "find_first_ticket",
            "signature": "(self, criteria: SearchCriteria) -> UnifiedTicket | None",
            "is_async": true,
            "docstring": {
              "short_description": "Return the first ticket that matches ``criteria`` if any.",
              "long_description": "This is a convenience method that should return the first matching\nticket from a search operation. It should optimize for performance\nby limiting results internally.",
              "params": [
                {
                  "name": "criteria",
                  "type": null,
                  "default": null,
                  "is_optional": null,
                  "description": "Parameters defining which ticket to search for."
                }
              ],
              "raises": [],
              "returns": {
                "type": "Optional[UnifiedTicket]",
                "description": "The first matching ticket or ``None`` if no tickets match.",
                "name": null
              }
            }
          },
          {
            "name": "create_ticket",
            "signature": "(self, ticket_data: UnifiedTicket) -> UnifiedTicket",
            "is_async": true,
            "docstring": {
              "short_description": "Create a new ticket in the system.",
              "long_description": "This method must be implemented by concrete adapters to handle ticket creation\nin the target ticketing system. The ticket data is provided in a unified format.",
              "params": [
                {
                  "name": "ticket_data",
                  "type": "UnifiedTicket",
                  "default": null,
                  "is_optional": false,
                  "description": "The ticket data to create. Contains all necessary fields in a \nsystem-agnostic format."
                }
              ],
              "raises": [],
              "returns": {
                "type": "UnifiedTicket",
                "description": "The created ticket object with system-generated identifiers and fields.",
                "name": null
              }
            }
          },
          {
            "name": "add_note",
            "signature": "(self, ticket_id: str, note: UnifiedNote) -> UnifiedNote",
            "is_async": true,
            "docstring": {
              "short_description": "Add a note to an existing ticket.",
              "long_description": "This method must be implemented by concrete adapters to attach notes/comments\nto tickets in the target system. The note content is provided in a unified format.",
              "params": [
                {
                  "name": "ticket_id",
                  "type": "str",
                  "default": null,
                  "is_optional": false,
                  "description": "Unique identifier of the target ticket."
                },
                {
                  "name": "note",
                  "type": "UnifiedNote",
                  "default": null,
                  "is_optional": false,
                  "description": "The note content and metadata to add."
                }
              ],
              "raises": [],
              "returns": {
                "type": "UnifiedNote",
                "description": "The added note object with system-generated metadata (e.g., timestamp, ID).",
                "name": null
              }
            }
          }
        ]
      }
    ],
    "functions": []
  },
  {
    "module_path": "src.ce.ticket_system_integration.unified_models",
    "module_docstring": {
      "short_description": null,
      "long_description": null,
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "UnifiedEntity",
        "docstring": {
          "short_description": "Base entity with optional ID and name.",
          "long_description": null,
          "params": [
            {
              "name": "id",
              "type": "Optional[int]",
              "default": "None",
              "is_optional": false,
              "description": "Unique identifier for the entity. Defaults to None."
            },
            {
              "name": "name",
              "type": "Optional[str]",
              "default": "None",
              "is_optional": false,
              "description": "Display name of the entity. Defaults to None."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": []
      },
      {
        "name": "UnifiedUser",
        "docstring": {
          "short_description": "Represents a user within the system.",
          "long_description": "Inherits attributes from `UnifiedEntity` and adds:",
          "params": [
            {
              "name": "email",
              "type": "Optional[str]",
              "default": "None",
              "is_optional": false,
              "description": "Email address of the user. Defaults to None."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": []
      },
      {
        "name": "UnifiedQueue",
        "docstring": {
          "short_description": "Represents a ticket queue.",
          "long_description": "Inherits attributes from `UnifiedEntity`.",
          "params": [],
          "raises": [],
          "returns": null
        },
        "methods": []
      },
      {
        "name": "UnifiedPriority",
        "docstring": {
          "short_description": "Represents a ticket priority level.",
          "long_description": "Inherits attributes from `UnifiedEntity`.",
          "params": [],
          "raises": [],
          "returns": null
        },
        "methods": []
      },
      {
        "name": "UnifiedStatus",
        "docstring": {
          "short_description": "Represents a ticket status.",
          "long_description": "Inherits attributes from `UnifiedEntity`.",
          "params": [],
          "raises": [],
          "returns": null
        },
        "methods": []
      },
      {
        "name": "UnifiedNote",
        "docstring": {
          "short_description": "Represents a note attached to a ticket.",
          "long_description": null,
          "params": [
            {
              "name": "id",
              "type": "Optional[str]",
              "default": "None",
              "is_optional": false,
              "description": "Unique identifier for the note. Defaults to None."
            },
            {
              "name": "body",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "Content of the note."
            },
            {
              "name": "created_at",
              "type": "datetime",
              "default": null,
              "is_optional": false,
              "description": "Timestamp when the note was created."
            },
            {
              "name": "is_internal",
              "type": "bool",
              "default": null,
              "is_optional": false,
              "description": "Indicates if the note is internal (not visible to customers)."
            },
            {
              "name": "author",
              "type": "UnifiedUser",
              "default": null,
              "is_optional": false,
              "description": "User who created the note."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": []
      },
      {
        "name": "UnifiedTicket",
        "docstring": {
          "short_description": "Unified representation of a support ticket.",
          "long_description": null,
          "params": [
            {
              "name": "id",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "Unique identifier for the ticket."
            },
            {
              "name": "subject",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "Subject line of the ticket."
            },
            {
              "name": "body",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "Main content/description of the ticket."
            },
            {
              "name": "custom_fields",
              "type": "Dict",
              "default": null,
              "is_optional": false,
              "description": "Additional custom field data associated with the ticket."
            },
            {
              "name": "queue",
              "type": "UnifiedQueue",
              "default": null,
              "is_optional": false,
              "description": "Queue to which the ticket belongs."
            },
            {
              "name": "priority",
              "type": "UnifiedPriority",
              "default": null,
              "is_optional": false,
              "description": "Priority level of the ticket."
            },
            {
              "name": "status",
              "type": "UnifiedStatus",
              "default": null,
              "is_optional": false,
              "description": "Current status of the ticket."
            },
            {
              "name": "owner",
              "type": "UnifiedUser",
              "default": null,
              "is_optional": false,
              "description": "User currently assigned to the ticket."
            },
            {
              "name": "notes",
              "type": "List[UnifiedNote]",
              "default": "empty list",
              "is_optional": false,
              "description": "List of notes attached to the ticket. Defaults to empty list."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": []
      },
      {
        "name": "SearchCriteria",
        "docstring": {
          "short_description": "Criteria for searching/filtering tickets.",
          "long_description": null,
          "params": [
            {
              "name": "id",
              "type": "Optional[str]",
              "default": "None",
              "is_optional": false,
              "description": "Ticket ID to search for. Defaults to None."
            },
            {
              "name": "subject",
              "type": "Optional[str]",
              "default": "None",
              "is_optional": false,
              "description": "Text to search in ticket subjects. Defaults to None."
            },
            {
              "name": "queue",
              "type": "Optional[UnifiedQueue]",
              "default": "None",
              "is_optional": false,
              "description": "Queue to filter by. Defaults to None."
            },
            {
              "name": "user",
              "type": "Optional[UnifiedUser]",
              "default": "None",
              "is_optional": false,
              "description": "User to filter by (e.g., owner). Defaults to None."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": []
      }
    ],
    "functions": []
  },
  {
    "module_path": "tests.experimental.test_anonymize_data",
    "module_docstring": {
      "short_description": "Tests for the anonymize_text function.",
      "long_description": "This module contains a suite of tests that verify the functionality of the `anonymize_text`\nfunction from the `open_ticket_ai.experimental.anonymize_data` module. The tests ensure\nthat various types of personal identifiable information (PII) are properly anonymized,\nincluding names, addresses, email addresses, phone numbers, IBANs, BICs, credit card numbers,\nand other sensitive data.\n\nThe tests are parameterized with a wide range of text examples containing different PII formats\nand contexts to ensure comprehensive coverage of anonymization scenarios.",
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [],
    "functions": [
      {
        "name": "test_remove_personal_info",
        "signature": "(text)",
        "is_async": false,
        "docstring": {
          "short_description": "Tests that the anonymize_text function removes all specified personal information.",
          "long_description": "This test is parameterized with various text examples containing personal data such as names,\naddresses, email addresses, phone numbers, IBANs, and credit card details. It verifies that\nafter processing by anonymize_text, none of the forbidden personal information strings remain.",
          "params": [
            {
              "name": "text",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "Input text containing personal information to be anonymized."
            }
          ],
          "raises": [],
          "returns": null
        }
      }
    ]
  },
  {
    "module_path": "tests.scripts.test_doc_generation.test_add_docstrings_generator",
    "module_docstring": {
      "short_description": "Unit tests for the DocstringGenerator functionality.",
      "long_description": "This module contains tests that verify the behavior of the DocstringGenerator class,\nparticularly its interaction with the OpenAI API and its ability to generate and insert\ndocstrings into Python code.\n\nNote: This test module uses a mock OpenAI client to avoid making real API calls during testing.",
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "MockClient",
        "docstring": {
          "short_description": "Mock client for testing OpenAI API interactions.",
          "long_description": "This class simulates the behavior of an OpenAI client by capturing API call arguments\nand returning predefined responses. It's designed specifically for testing the\nDocstringGenerator functionality.",
          "params": [
            {
              "name": "called_with",
              "type": "dict",
              "default": null,
              "is_optional": false,
              "description": "Stores the keyword arguments passed to the last API call."
            },
            {
              "name": "chat",
              "type": "SimpleNamespace",
              "default": null,
              "is_optional": false,
              "description": "Mock structure mimicking OpenAI's chat completions interface."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, response_content: str)",
            "is_async": false,
            "docstring": {
              "short_description": "Initializes the mock client with a fixed response content.",
              "long_description": null,
              "params": [
                {
                  "name": "response_content",
                  "type": "str",
                  "default": null,
                  "is_optional": false,
                  "description": "The content that will be returned in the mock API response."
                }
              ],
              "raises": [],
              "returns": null
            }
          }
        ]
      }
    ],
    "functions": [
      {
        "name": "test_add_docstrings_to_file_content",
        "signature": "(tmp_path: Path)",
        "is_async": false,
        "docstring": {
          "short_description": "Tests DocstringGenerator's ability to process AI responses and integrate with OpenAI client.",
          "long_description": "This test verifies that:\n- The DocstringGenerator correctly cleans and processes AI-generated responses\n- The generator properly utilizes the provided OpenAI client\n- File content is updated as expected with generated docstrings",
          "params": [
            {
              "name": "tmp_path",
              "type": "Path",
              "default": null,
              "is_optional": false,
              "description": "Temporary directory path provided by pytest fixture for test isolation."
            }
          ],
          "raises": [],
          "returns": null
        }
      }
    ]
  },
  {
    "module_path": "tests.scripts.test_license_script",
    "module_docstring": {
      "short_description": "Tests for the license_script module.",
      "long_description": "This module contains unit tests for the functions in `open_ticket_ai.scripts.license_script`.\nIt tests the functionality of:\n- Finding the start of code in a file\n- Updating license notices in files within a directory\n- Handling various file types and content scenarios\n\nThe tests use pytest fixtures to create temporary directories with test files\nand parametrized tests to cover multiple input cases.",
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [],
    "functions": [
      {
        "name": "setup_test_directory",
        "signature": "(tmp_path)",
        "is_async": false,
        "docstring": {
          "short_description": "Sets up a temporary directory with various files for testing.",
          "long_description": "This fixture creates a temporary directory structure with multiple test files\nrepresenting different scenarios:\n\n- Python files with only code\n- Python files with only comments\n- Python files with mixed comments and code\n- Empty Python files\n- Non-Python text files\n- Python files that already have the new license notice\n\nAfter the test runs, the temporary directory is automatically cleaned up.",
          "params": [
            {
              "name": "tmp_path",
              "type": null,
              "default": null,
              "is_optional": null,
              "description": "Pytest fixture providing a temporary directory path."
            }
          ],
          "raises": [],
          "returns": {
            "type": "str",
            "description": "The path to the temporary test directory.",
            "name": null
          }
        }
      },
      {
        "name": "test_find_start_of_code",
        "signature": "(lines, expected_index)",
        "is_async": false,
        "docstring": {
          "short_description": "Tests the find_start_of_code function with various line inputs.",
          "long_description": "This test uses parametrized inputs to verify the function correctly identifies\nthe starting index of non-comment, non-whitespace code in different scenarios.",
          "params": [
            {
              "name": "lines",
              "type": "list[str]",
              "default": null,
              "is_optional": false,
              "description": "List of strings representing lines of a file."
            },
            {
              "name": "expected_index",
              "type": "int",
              "default": null,
              "is_optional": false,
              "description": "The expected index where the code starts."
            }
          ],
          "raises": [],
          "returns": null
        }
      },
      {
        "name": "test_update_license_in_files",
        "signature": "(setup_test_directory)",
        "is_async": false,
        "docstring": {
          "short_description": "Tests the update_license_in_files function by updating files in a test directory.",
          "long_description": "This test verifies that:\n\n- Python files get the new license notice at the top while retaining their original content\n- Already licensed files are updated without duplicating the license\n- Non-Python files remain unmodified\n- Files in subdirectories are processed correctly\n- Empty files are handled appropriately",
          "params": [
            {
              "name": "setup_test_directory",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "Pytest fixture that sets up a temporary test directory."
            }
          ],
          "raises": [],
          "returns": null
        }
      }
    ]
  },
  {
    "module_path": "tests.src.core.config_test",
    "module_docstring": {
      "short_description": "Tests for the configuration models and loading functionality.",
      "long_description": "This module contains unit tests for the configuration models (`SchedulerConfig`,\n`OpenTicketAIConfig`) and the `load_config` function in the\n`open_ticket_ai.src.ce.core.config.config_models` module.\n\nThe tests cover:\n  - Validation of the `SchedulerConfig` model.\n  - Validation of the `OpenTicketAIConfig` model, including:\n      * Required components (non-empty lists for core components).\n      * Correct parsing of a valid configuration.\n      * Cross-referencing of components in pipelines.\n      * Handling of duplicate component IDs.\n  - The `load_config` function's behavior when the configuration file is missing the root key.\n\nThe tests use pytest fixtures and parametrization to cover various scenarios.",
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "TestSchedulerConfig",
        "docstring": {
          "short_description": "Test cases for validating the SchedulerConfig model.",
          "long_description": null,
          "params": [],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "test_valid_scheduler_config",
            "signature": "(self)",
            "is_async": false,
            "docstring": {
              "short_description": "Tests that a valid scheduler configuration is parsed correctly.",
              "long_description": null,
              "params": [],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "test_scheduler_config_invalid_interval_raises_validation_error",
            "signature": "(self, interval)",
            "is_async": false,
            "docstring": {
              "short_description": "Tests validation error when scheduler interval is non-positive.",
              "long_description": null,
              "params": [
                {
                  "name": "interval",
                  "type": "int",
                  "default": null,
                  "is_optional": false,
                  "description": "Invalid interval value to test."
                }
              ],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "test_scheduler_config_invalid_unit_raises_validation_error",
            "signature": "(self)",
            "is_async": false,
            "docstring": {
              "short_description": "Tests validation error when scheduler unit is invalid.",
              "long_description": null,
              "params": [],
              "raises": [],
              "returns": null
            }
          }
        ]
      },
      {
        "name": "TestOpenTicketAIConfig",
        "docstring": {
          "short_description": "Test cases for validating the OpenTicketAIConfig model.",
          "long_description": null,
          "params": [],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "test_empty_list_for_core_components_raises_validation_error",
            "signature": "(self, list_name, minimal_config_dict)",
            "is_async": false,
            "docstring": {
              "short_description": "Tests validation error when core component lists are empty.",
              "long_description": null,
              "params": [
                {
                  "name": "list_name",
                  "type": "str",
                  "default": null,
                  "is_optional": false,
                  "description": "Name of the component list to empty."
                },
                {
                  "name": "minimal_config_dict",
                  "type": "dict",
                  "default": null,
                  "is_optional": false,
                  "description": "Minimal valid configuration fixture."
                }
              ],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "test_valid_open_ticket_ai_config_parses_correctly",
            "signature": "(self, minimal_config_dict)",
            "is_async": false,
            "docstring": {
              "short_description": "Tests successful parsing of a valid configuration.",
              "long_description": null,
              "params": [
                {
                  "name": "minimal_config_dict",
                  "type": "dict",
                  "default": null,
                  "is_optional": false,
                  "description": "Minimal valid configuration fixture."
                }
              ],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "test_invalid_cross_reference_raises_value_error",
            "signature": "(self, list_name_to_alter, pipe_index, expected_error_message_part, minimal_config_dict)",
            "is_async": false,
            "docstring": {
              "short_description": "Tests validation error when pipeline references invalid components.",
              "long_description": null,
              "params": [
                {
                  "name": "list_name_to_alter",
                  "type": "str",
                  "default": null,
                  "is_optional": false,
                  "description": "Component list to modify."
                },
                {
                  "name": "pipe_index",
                  "type": "int",
                  "default": null,
                  "is_optional": false,
                  "description": "Index in pipeline's pipes to modify."
                },
                {
                  "name": "expected_error_message_part",
                  "type": "str",
                  "default": null,
                  "is_optional": false,
                  "description": "Expected substring in error message."
                },
                {
                  "name": "minimal_config_dict",
                  "type": "dict",
                  "default": null,
                  "is_optional": false,
                  "description": "Minimal valid configuration fixture."
                }
              ],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "test_duplicate_ids_in_component_list_allowed_by_b_but_picked_by_set_logic",
            "signature": "(self, minimal_config_dict)",
            "is_async": false,
            "docstring": {
              "short_description": "Tests behavior when duplicate component IDs exist in component lists.",
              "long_description": "Verifies:\n  1. Duplicate IDs are allowed during parsing.\n  2. Pipeline references resolve correctly using set-based lookup.",
              "params": [
                {
                  "name": "minimal_config_dict",
                  "type": "dict",
                  "default": null,
                  "is_optional": false,
                  "description": "Minimal valid configuration fixture."
                }
              ],
              "raises": [],
              "returns": null
            }
          }
        ]
      },
      {
        "name": "TestLoadConfig",
        "docstring": {
          "short_description": "Test cases for the load_config function.",
          "long_description": null,
          "params": [],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "test_load_config_missing_root_key_raises_key_error",
            "signature": "(self, tmp_path)",
            "is_async": false,
            "docstring": {
              "short_description": "Tests KeyError when configuration file lacks root key.",
              "long_description": null,
              "params": [
                {
                  "name": "tmp_path",
                  "type": "pathlib.Path",
                  "default": null,
                  "is_optional": false,
                  "description": "Temporary directory fixture."
                }
              ],
              "raises": [],
              "returns": null
            }
          }
        ]
      }
    ],
    "functions": [
      {
        "name": "minimal_config_dict",
        "signature": "()",
        "is_async": false,
        "docstring": {
          "short_description": "Build the smallest valid dict for ``OpenTicketAIConfig``.",
          "long_description": "The config now follows the new pipes and filters structure with\n``pipelines`` instead of ``attribute_predictors``.",
          "params": [],
          "raises": [],
          "returns": {
            "type": "dict",
            "description": "Minimal valid configuration dictionary for testing.",
            "name": null
          }
        }
      }
    ]
  },
  {
    "module_path": "tests.src.core.util_test",
    "module_docstring": {
      "short_description": "Tests for the `core.util` module.",
      "long_description": "This module contains unit tests for the utility functions and configuration handling\nin the `core.util` module of the `open_ticket_ai` project.\n\nThe tests are organized into three main sections:\n\n1. **Tests for `path_util.find_project_root`**:\n   - Verifies that the project root is correctly identified.\n   - Checks error handling when the project name is invalid.\n\n2. **Tests for `pretty_print_config.pretty_print_config`**:\n   - Ensures that the configuration is printed in the expected YAML format.\n\n3. **Tests for `create_json_config_schema`**:\n   - Validates the structure of the generated JSON schema.\n   - Checks that the schema file is correctly written to the filesystem.\n\nThese tests use `pytest` and rely on fixtures for temporary directories and environment patching.",
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "DummyModel",
        "docstring": {
          "short_description": "A dummy Pydantic model for testing purposes.",
          "long_description": null,
          "params": [
            {
              "name": "foo",
              "type": "int",
              "default": null,
              "is_optional": false,
              "description": "An integer attribute for testing."
            },
            {
              "name": "bar",
              "type": "str",
              "default": null,
              "is_optional": false,
              "description": "A string attribute for testing."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": []
      }
    ],
    "functions": [
      {
        "name": "test_find_project_root_returns_project_directory",
        "signature": "()",
        "is_async": false,
        "docstring": {
          "short_description": "Tests that find_project_root correctly identifies the project root directory.",
          "long_description": "Verifies:\n    - The found directory has the expected name\n    - The current test file resides within the found directory\n    - The expected config file exists in the root directory",
          "params": [],
          "raises": [],
          "returns": null
        }
      },
      {
        "name": "test_find_project_root_invalid_name_raises",
        "signature": "()",
        "is_async": false,
        "docstring": {
          "short_description": "Tests that find_project_root raises FileNotFoundError with invalid project name.",
          "long_description": "Verifies:\n    - FileNotFoundError is raised when an invalid project name is provided.",
          "params": [],
          "raises": [],
          "returns": null
        }
      },
      {
        "name": "test_pretty_print_config_outputs_yaml",
        "signature": "()",
        "is_async": false,
        "docstring": {
          "short_description": "Tests that pretty_print_config outputs configuration as expected YAML.",
          "long_description": "Verifies:\n    - Output contains exactly one element\n    - Output element is a Syntax object\n    - Output YAML matches the expected serialized configuration",
          "params": [],
          "raises": [],
          "returns": null
        }
      },
      {
        "name": "test_root_config_schema_contains_open_ticket_ai",
        "signature": "()",
        "is_async": false,
        "docstring": {
          "short_description": "Tests that the generated JSON schema contains the expected 'open_ticket_ai' property.",
          "long_description": "Verifies:\n    - The 'open_ticket_ai' property exists in the schema's properties.",
          "params": [],
          "raises": [],
          "returns": null
        }
      }
    ]
  },
  {
    "module_path": "tests.src.run.test_pipeline",
    "module_docstring": {
      "short_description": "Module providing dummy implementations for pipeline components testing.",
      "long_description": "This module defines several classes that mimic the behavior of real pipeline components\n(like data preparer, AI model, and result modifier) for the purpose of testing the pipeline\nwithout the need for actual external services or complex setups.\n\nThe classes included are:\n\n- `DummyPreparer`: Simulates data preparation by wrapping input values in a string.\n- `DummyAI`: Simulates an AI model by returning formatted prompts as responses.\n- `DummyModifier`: Simulates result modification and tracks call arguments.",
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "DummyPreparer",
        "docstring": {
          "short_description": "A dummy implementation of a data preparer for testing purposes.",
          "long_description": "This class simulates the behavior of preparing input data by applying\na simple transformation.",
          "params": [],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "prepare",
            "signature": "(self, data)",
            "is_async": false,
            "docstring": {
              "short_description": "Transforms input `data` by wrapping a specific value in a string.",
              "long_description": null,
              "params": [
                {
                  "name": "data",
                  "type": "dict",
                  "default": null,
                  "is_optional": false,
                  "description": "Input data dictionary expected to contain a key `'v'`."
                }
              ],
              "raises": [],
              "returns": {
                "type": "str",
                "description": "A formatted string containing the value from `data['v']`.",
                "name": null
              }
            }
          }
        ]
      },
      {
        "name": "DummyAI",
        "docstring": {
          "short_description": "A dummy implementation of an AI model for testing purposes.",
          "long_description": "This class simulates the behavior of generating responses from prompts\nby returning a formatted version of the input prompt.",
          "params": [],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "generate_response",
            "signature": "(self, prompt)",
            "is_async": false,
            "docstring": {
              "short_description": "Generates a simulated AI response based on the input `prompt`.",
              "long_description": null,
              "params": [
                {
                  "name": "prompt",
                  "type": "str",
                  "default": null,
                  "is_optional": false,
                  "description": "The input prompt for the AI model."
                }
              ],
              "raises": [],
              "returns": {
                "type": "str",
                "description": "A formatted string containing the input `prompt`.",
                "name": null
              }
            }
          }
        ]
      },
      {
        "name": "DummyModifier",
        "docstring": {
          "short_description": "A dummy implementation of a result modifier for testing purposes.",
          "long_description": "This class simulates modifying model results and tracks the last arguments\npassed to the modify method.",
          "params": [
            {
              "name": "called_with",
              "type": "tuple",
              "default": null,
              "is_optional": false,
              "description": "Stores the last arguments passed to the `modify` method.\nFormat: `(ticket_id, model_result)`."
            }
          ],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "__init__",
            "signature": "(self)",
            "is_async": false,
            "docstring": {
              "short_description": "Initializes the DummyModifier instance.",
              "long_description": "Sets up an instance variable to track the last arguments used in modify calls.",
              "params": [],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "modify",
            "signature": "(self, ticket_id: str, model_result)",
            "is_async": false,
            "docstring": {
              "short_description": "Simulates modifying a model result and stores the input arguments.",
              "long_description": null,
              "params": [
                {
                  "name": "ticket_id",
                  "type": "str",
                  "default": null,
                  "is_optional": false,
                  "description": "Identifier for the ticket being processed."
                },
                {
                  "name": "model_result",
                  "type": "object",
                  "default": null,
                  "is_optional": false,
                  "description": "The result from the model that would be modified."
                }
              ],
              "raises": [],
              "returns": {
                "type": "str",
                "description": "A fixed string indicating completion.",
                "name": null
              }
            }
          }
        ]
      }
    ],
    "functions": []
  },
  {
    "module_path": "tests.src.test_app_main",
    "module_docstring": {
      "short_description": "Tests for the application and main module of the Open Ticket AI command-line tool.",
      "long_description": "This module contains unit tests for the `App` class and the `main` module, focusing on\nthe application's core functionality, including validation, scheduling, logging, and\nthe main execution flow.",
      "params": [],
      "raises": [],
      "returns": null
    },
    "classes": [
      {
        "name": "TestAppRun",
        "docstring": {
          "short_description": "Test suite for the `App.run()` method functionality.",
          "long_description": null,
          "params": [],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "test_run_validation_passes",
            "signature": "(self, monkeypatch)",
            "is_async": false,
            "docstring": {
              "short_description": "Tests that `App.run()` executes validation and scheduling when validation passes.",
              "long_description": "Mocks the scheduler and console to simulate a `KeyboardInterrupt` to break the loop.\n\nVerifies:\n    - The validator is called exactly once\n    - The orchestrator sets schedules exactly once\n    - The console output occurs as expected",
              "params": [
                {
                  "name": "monkeypatch",
                  "type": "`pytest.MonkeyPatch`",
                  "default": null,
                  "is_optional": false,
                  "description": "Fixture for modifying runtime behavior."
                }
              ],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "test_run_validation_error_logs",
            "signature": "(self, monkeypatch, caplog)",
            "is_async": false,
            "docstring": {
              "short_description": "Tests that `App.run()` logs validation errors appropriately.",
              "long_description": "Mocks the validator to raise an exception and checks the logs.\n\nVerifies:\n    - Validation errors are logged at `ERROR` level\n    - Orchestrator still attempts to set schedules after validation failure",
              "params": [
                {
                  "name": "monkeypatch",
                  "type": "`pytest.MonkeyPatch`",
                  "default": null,
                  "is_optional": false,
                  "description": "Fixture for modifying runtime behavior."
                },
                {
                  "name": "caplog",
                  "type": "`pytest.LogCaptureFixture`",
                  "default": null,
                  "is_optional": false,
                  "description": "Fixture for capturing log messages."
                }
              ],
              "raises": [],
              "returns": null
            }
          }
        ]
      },
      {
        "name": "TestMainModule",
        "docstring": {
          "short_description": "Test suite for `main` module functionality.",
          "long_description": null,
          "params": [],
          "raises": [],
          "returns": null
        },
        "methods": [
          {
            "name": "test_main_sets_logging_level",
            "signature": "(self, monkeypatch)",
            "is_async": false,
            "docstring": {
              "short_description": "Tests that `main()` correctly sets logging verbosity levels.",
              "long_description": "Verifies that the logging level is set to `INFO` when `verbose=True`.",
              "params": [
                {
                  "name": "monkeypatch",
                  "type": "`pytest.MonkeyPatch`",
                  "default": null,
                  "is_optional": false,
                  "description": "Fixture for modifying runtime behavior."
                }
              ],
              "raises": [],
              "returns": null
            }
          },
          {
            "name": "test_start_creates_container_and_runs_app",
            "signature": "(self, monkeypatch, capsys)",
            "is_async": false,
            "docstring": {
              "short_description": "Tests the full application startup sequence.",
              "long_description": "Verifies:\n    - `DIContainer` dependency container is initialized\n    - `App` instance is retrieved and executed\n    - Expected console output (`Figlet` art) is present",
              "params": [
                {
                  "name": "monkeypatch",
                  "type": "`pytest.MonkeyPatch`",
                  "default": null,
                  "is_optional": false,
                  "description": "Fixture for modifying runtime behavior."
                },
                {
                  "name": "capsys",
                  "type": "`pytest.CaptureFixture`",
                  "default": null,
                  "is_optional": false,
                  "description": "Fixture for capturing stdout/stderr."
                }
              ],
              "raises": [],
              "returns": null
            }
          }
        ]
      }
    ],
    "functions": []
  }
]